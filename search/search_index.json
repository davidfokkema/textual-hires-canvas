{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"High-resolution drawing canvas for Textual apps","text":"<p>Textual is an excellent Python framework for building applications in the terminal, or on the web. This library provides a canvas widget which your app can draw on using primitives like <code>set_pixel()</code>, <code>draw_line()</code> and <code>draw_rectangle_box()</code>. The canvas can also draw using high-resolution characters like unicode half blocks, quadrants and 8-dot Braille characters. It may still be apparent that these are drawn using characters that take up a full block in the terminal, especially when lines cross. However, the use of these characters can reduce the line thickness and improve the resolution tremendously.</p>"},{"location":"#screenshots","title":"Screenshots","text":""},{"location":"#running-the-demo-installation","title":"Running the demo / installation","text":"<p>If you have uv installed, run</p> <pre><code>uvx textual-hires-canvas\n</code></pre> <p>If you use pipx, replace <code>uvx</code> with <code>pipx</code>. Alternatively, install the package with <code>pip</code> and run the demo:</p> <pre><code>pip install textual-hires-canvas\npython -m textual_hires_canvas.demo\n</code></pre>"},{"location":"#tutorial","title":"Tutorial","text":"<p>A simple example of using the canvas widget in your Textual app is given below. </p> <pre><code>from textual.app import App, ComposeResult\n\nfrom textual_hires_canvas import Canvas, HiResMode, TextAlign\n\n\nclass MinimalApp(App[None]):\n    def compose(self) -&gt; ComposeResult:\n        yield Canvas(40, 20)\n\n    def on_mount(self) -&gt; None:\n        canvas = self.query_one(Canvas)\n        canvas.draw_rectangle_box(0, 0, 39, 19, thickness=2)\n        canvas.draw_line(1, 1, 38, 18, style=\"green\")\n        canvas.draw_hires_line(1, 18.5, 38.5, 1, HiResMode.BRAILLE, style=\"blue\")\n        canvas.write_text(\n            20,\n            1,\n            \"A [italic]simple[/] demo of the [bold yellow]Canvas[/]\",\n            TextAlign.CENTER,\n        )\n\n\nif __name__ == \"__main__\":\n    MinimalApp().run()\n</code></pre> <p>Here, the <code>Canvas</code> widget is initialised with size 40 by 20 and a rectangular box, a line, a high-resolution line and some text is displayed. Coordinates are given in (x, y) fashion where (0, 0) is the top-left corner of the widget. The <code>draw_line()</code> method accepts a <code>char</code> argument which you can pass any unicode character you'd like to draw in the terminal. The <code>style</code> argument accepts Textual/Rich styles like <code>green</code> or <code>yellow on blue</code>. The <code>HiresMode</code>s are <code>HALFBLOCK</code>, <code>QUADRANT</code> and <code>BRAILLE</code>.</p>"},{"location":"#resizing-the-canvas","title":"Resizing the canvas","text":"<p>To automatically resize the Canvas to fit the available space in your app or the terminal, you can handle the <code>Canvas.Resize</code> event and call <code>Canvas.reset(size=event.size)</code> to resize the canvas. Be aware that the canvas is cleared and you have to redraw, like this: </p> <pre><code>from textual import on\nfrom textual.app import App, ComposeResult\n\nfrom textual_hires_canvas import Canvas, HiResMode, TextAlign\n\n\nclass MinimalApp(App[None]):\n    def compose(self) -&gt; ComposeResult:\n        yield Canvas()\n\n    @on(Canvas.Resize)\n    def draw(self, event: Canvas.Resize):\n        canvas = event.canvas\n        size = event.size\n        canvas.reset(size=event.size)\n\n        canvas.draw_rectangle_box(0, 0, size.width - 1, size.height - 1, thickness=2)\n        canvas.draw_line(1, 1, size.width - 2, size.height - 2, style=\"green\")\n        canvas.draw_hires_line(\n            1, size.height - 1.5, size.width - 1.5, 1, HiResMode.BRAILLE, style=\"blue\"\n        )\n        canvas.write_text(\n            size.width // 2,\n            1,\n            \"A [italic]simple[/] demo of the [bold yellow]Canvas[/]\",\n            TextAlign.CENTER,\n        )\n\n\nif __name__ == \"__main__\":\n    MinimalApp().run()\n</code></pre>"},{"location":"#the-full-demo-code","title":"The full demo code","text":"<p>Finally, the code of the demo is given below, showing how you can handle simple animations:</p> <pre><code>from math import floor\n\nfrom textual import on\nfrom textual.app import App, ComposeResult\n\nfrom textual_hires_canvas import Canvas, HiResMode\n\n\nclass DemoApp(App[None]):\n    _box_x_pos = 0\n    _box_y_pos = 0\n    _text_x_pos = 0.0\n\n    _box_x_step = 1\n    _box_y_step = 1\n    _text_x_step = 0.5\n\n    def compose(self) -&gt; ComposeResult:\n        yield Canvas(1, 1)\n\n    def on_mount(self) -&gt; None:\n        self.set_interval(1 / 10, self.redraw_canvas)\n\n    @on(Canvas.Resize)\n    def resize(self, event: Canvas.Resize) -&gt; None:\n        event.canvas.reset(size=event.size)\n\n    def redraw_canvas(self) -&gt; None:\n        canvas = self.query_one(Canvas)\n        canvas.reset()\n        canvas.draw_hires_line(2, 10, 78, 2, hires_mode=HiResMode.BRAILLE, style=\"blue\")\n        canvas.draw_hires_line(2, 5, 78, 10, hires_mode=HiResMode.BRAILLE)\n        canvas.draw_line(0, 0, 8, 8)\n        canvas.draw_line(0, 19, 39, 0, char=\"X\", style=\"red\")\n        canvas.write_text(\n            floor(self._text_x_pos),\n            10,\n            \"[green]This text is [bold]easy[/bold] to read\",\n        )\n        canvas.draw_rectangle_box(\n            self._box_x_pos,\n            self._box_y_pos,\n            self._box_x_pos + 20,\n            self._box_y_pos + 10,\n            thickness=2,\n        )\n        self._box_x_pos += self._box_x_step\n        if (self._box_x_pos &lt;= 0) or (self._box_x_pos + 20 &gt;= canvas.size.width - 1):\n            self._box_x_step *= -1\n        self._box_y_pos += self._box_y_step\n        if (self._box_y_pos &lt;= 0) or (self._box_y_pos + 10 &gt;= canvas.size.height - 1):\n            self._box_y_step *= -1\n        self._text_x_pos += self._text_x_step\n        if self._text_x_pos &gt;= canvas.size.width + 20:\n            self._text_x_pos = -20\n\n\ndef main():\n    DemoApp().run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#list-of-canvas-methods","title":"List of canvas methods","text":"<ul> <li><code>reset()</code> or <code>reset(size)</code>: clear the canvas.</li> <li><code>get_pixel(x, y)</code>: get character at pixel coordinages.</li> <li><code>set_pixel(x, y, char, style)</code>: set a character at pixel coordinates.</li> <li><code>set_pixels(coordinates, char, style)</code>: set multiple pixels.</li> <li><code>set_hires_pixels(coordinates, hires_mode, style)</code>: set high-resolution pixels.</li> <li><code>draw_line(x0, y0, x1, y1, char, style)</code>: draw a line consisting of specific characters.</li> <li><code>draw_lines(coordinates, char, style)</code>: draw multiple lines.</li> <li><code>draw_hires_line(x0, y0, x1, y1, hires_mode, style)</code>: draw a high-resolution line using a particular mode.</li> <li><code>draw_hires_lines(coordinates, hires_mode, style)</code>: draw multiple high-resolution lines. </li> <li><code>draw_rectangle_box(x0, y0, x1, y1, thickness, style)</code>: draw a rectangle using box-drawing characters.</li> </ul>"},{"location":"#alternatives","title":"Alternatives","text":"<p>Textual-canvas by Dave Pearson is much better suited to display a large bitmap image with a scrollable viewport. It uses half-block characters to create square pixels.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#textual_hires_canvas.Canvas","title":"<code>Canvas</code>","text":"<p>               Bases: <code>Widget</code></p> <p>A widget that renders a 2D canvas.</p> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>class Canvas(Widget):\n    \"\"\"A widget that renders a 2D canvas.\"\"\"\n\n    @dataclass\n    class Resize(Message):\n        canvas: \"Canvas\"\n        size: Size\n\n    default_hires_mode: HiResMode\n\n    _canvas_size: Size\n    _canvas_region: Region\n    _buffer: list[list[str]]\n    _styles: list[list[str]]\n\n    # Style cache to avoid reparsing identical style strings\n    _style_cache: dict[str, Style] = {}\n\n    def __init__(\n        self,\n        width: int = 40,\n        height: int = 20,\n        default_hires_mode: HiResMode | None = HiResMode.BRAILLE,\n        name: str | None = None,\n        id: str | None = None,\n        classes: str | None = None,\n        disabled: bool = False,\n    ):\n        \"\"\"Initialize the Canvas widget.\n\n        Args:\n            width: The width of the canvas. Defaults to 40.\n            height: The height of the canvas. Defaults to 20.\n            default_hires_mode: The default high-resolution mode. Defaults to\n                HiresMode.BRAILLE.\n            name: The name of the widget. Defaults to None.\n            id: The ID of the widget. Defaults to None.\n            classes: The CSS classes of the widget. Defaults to None.\n            disabled: Whether the widget is disabled. Defaults to False.\n        \"\"\"\n        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n\n        self._refreshes_pending: int = 0\n        # reference count batch refreshes\n\n        self._buffer = []\n        self._styles = []\n        self._canvas_size = Size(0, 0)\n        self._canvas_region = Region()\n\n        self.default_hires_mode = default_hires_mode or HiResMode.BRAILLE\n\n        self.reset(size=Size(width, height), refresh=False)\n\n    @contextmanager\n    def batch_refresh(self) -&gt; Iterator[None]:\n        \"\"\"Context manager that defers call to refresh until exiting the context.\n\n        This is useful when making multiple changes to the canvas and only wanting\n        to trigger refresh once at the end.\n\n        Example:\n            ```python\n            with canvas.batch_changes():\n                canvas.set_pixel(0, 0)\n                canvas.set_pixel(1, 1)\n                canvas.set_pixel(2, 2)\n            # Refresh called\n            ```\n\n        Yields:\n            Iterator[None]: A context manager.\n        \"\"\"\n        self._refreshes_pending += 1\n        try:\n            yield\n        finally:\n            self._refreshes_pending -= 1\n            if self._refreshes_pending == 0:\n                self.refresh()\n\n    @asynccontextmanager\n    async def async_batch_refresh(self) -&gt; AsyncIterator[None]:\n        \"\"\"Async context manager that defers call to refresh until exiting the context.\n\n        This is useful when making multiple asynchronous changes to the canvas and only wanting\n        to trigger refresh once at the end.\n\n        Example:\n                Yields:\n        AsyncIterator[None]: An async context manager.\n        \"\"\"\n        self._refreshes_pending += 1\n        try:\n            yield\n        finally:\n            self._refreshes_pending -= 1\n            if self._refreshes_pending == 0:\n                self.refresh()\n\n    def refresh(\n        self,\n        *regions: Region,\n        repaint: bool = True,\n        layout: bool = False,\n        recompose: bool = False,\n    ) -&gt; Self:\n        if self._refreshes_pending:\n            return self\n        super().refresh(*regions, repaint=repaint, layout=layout, recompose=recompose)\n        return self\n\n    def _on_resize(self, event: Resize) -&gt; None:\n        self.post_message(self.Resize(canvas=self, size=event.size))\n\n    def reset(self, size: Size | None = None, refresh: bool = True) -&gt; None:\n        \"\"\"Resets the canvas to the specified size or to the current size if no size is provided.\n        Clears buffers,styles and dirty cache, and resets the canvas size.\n\n        Args:\n            size: The new size for the canvas.\n            refresh: Whether to refresh the canvas after resetting.\n        Returns:\n            self for chaining.\n        \"\"\"\n        # Update size and regions if provided\n        if size:\n            self._canvas_size = size\n            self._canvas_region = Region(0, 0, size.width, size.height)\n\n        # Initialize buffers if we have a valid size\n        if self._canvas_size:\n            width = self._canvas_size.width\n            height = self._canvas_size.height\n\n            # More efficient buffer creation using list comprehension with multiplication\n            # This is significantly faster than nested loops for large buffers\n            self._buffer = [[\" \"] * width for _ in range(height)]\n            self._styles = [[\"\"] * width for _ in range(height)]\n\n        # Only refresh if requested\n        if refresh:\n            self.refresh()\n\n    def render_line(self, y: int) -&gt; Strip:\n        \"\"\"Renders a single line of the canvas at the given y-coordinate.\n\n        Args:\n            y: The y-coordinate of the line.\n        Returns:\n            A Strip representing the line.\n        \"\"\"\n        # Fast path for out-of-bounds or uninitialized\n        if not self._canvas_size.area or y &gt;= self._canvas_size.height:\n            return Strip.blank(cell_length=0)\n\n        buffer_line = self._buffer[y]\n        styles_line = self._styles[y]\n\n        # Fast path for blank lines\n        if all(char == \" \" for char in buffer_line):\n            return Strip.blank(cell_length=len(buffer_line))\n\n        # Create segments with batching by style\n        segments: list[Segment] = []\n        append = segments.append  # Local reference for faster calls\n\n        # Batch processing for same style segments\n        current_style_str = None\n        current_style_obj = None\n        current_text = \"\"\n\n        for char, style_str in zip(buffer_line, styles_line):\n            # When style changes, add current batch and start new one\n            if style_str != current_style_str:\n                # Add current batch if it exists\n                if current_text:\n                    append(Segment(current_text, style=current_style_obj))\n\n                # Start new batch\n                current_style_str = style_str\n                current_text = char\n\n                # Get style object from cache or create new one\n                if style_str:\n                    if style_str not in self._style_cache:\n                        self._style_cache[style_str] = Style.parse(style_str)\n                    current_style_obj = self._style_cache[style_str]\n                else:\n                    current_style_obj = None\n            else:\n                # Add to current batch\n                current_text += char\n\n        # Add the final batch\n        if current_text:\n            append(Segment(current_text, style=current_style_obj))\n\n        return Strip(segments).simplify()\n\n    def get_pixel(self, x: int, y: int) -&gt; tuple[str, str]:\n        \"\"\"Retrieves the character and style of a single pixel at the given coordinates.\n\n        Args:\n            x: The x-coordinate of the pixel.\n            y: The y-coordinate of the pixel.\n        Returns:\n            A tuple containing the character and style of the pixel.\n        \"\"\"\n        return self._buffer[y][x], self._styles[y][x]\n\n    def set_pixel(self, x: int, y: int, char: str = \"\u2588\", style: str = \"white\") -&gt; None:\n        \"\"\"Sets a single pixel at the given coordinates.\n        Also marks it dirty for refreshing.\n\n        Args:\n            x: The x-coordinate of the pixel.\n            y: The y-coordinate of the pixel.\n            char: The character to draw.\n            style: The style to apply to the character.\n        \"\"\"\n        # Fast rejection path without assert for performance\n        if not (\n            0 &lt;= x &lt; self._canvas_region.width and 0 &lt;= y &lt; self._canvas_region.height\n        ):\n            return\n\n        self._buffer[y][x] = char\n        self._styles[y][x] = style\n        self.refresh()\n\n    def set_pixels(\n        self,\n        coordinates: Iterable[tuple[int, int]],\n        char: str = \"\u2588\",\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Sets multiple pixels at the given coordinates.\n\n        Args:\n            coordinates: An iterable of tuples representing the coordinates of the pixels.\n            char: The character to draw.\n            style: The style to apply to the character.\n        \"\"\"\n        # Check if we have coordinates\n        coord_list = list(coordinates)\n        if not coord_list:\n            return\n\n        # Batch updates to avoid calling refresh for each pixel\n        # Cache properties for faster access in the loop\n        buffer = self._buffer\n        styles = self._styles\n        width = self._canvas_region.width\n        height = self._canvas_region.height\n\n        # Process all pixels first, then refresh once\n        for x, y in coord_list:\n            if 0 &lt;= x &lt; width and 0 &lt;= y &lt; height:\n                buffer[y][x] = char\n                styles[y][x] = style\n\n        # Only refresh once after all updates\n        self.refresh()\n\n    def set_hires_pixels(\n        self,\n        coordinates: Iterable[tuple[FloatScalar, FloatScalar]],\n        hires_mode: HiResMode | None = None,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Sets multiple pixels at the given coordinates using the specified Hi-Res mode.\n\n        Args:\n            coordinates: An iterable of tuples representing the coordinates of the pixels.\n            hires_mode: The Hi-Res mode to use.\n            style: The style to apply to the character.\n        \"\"\"\n        # Use default mode if none provided\n        hires_mode = hires_mode or self.default_hires_mode\n        pixel_size = hires_sizes[hires_mode]\n        pixel_info = pixels.get(hires_mode)\n        assert pixel_info is not None\n\n        # Group coordinates by their cell position to minimize buffer operations\n        cells_to_update: dict[tuple[int, int], set[tuple[int, int]]] = {}\n\n        # Pre-compute these values outside the loop for better performance\n        w_factor = pixel_size.width\n        h_factor = pixel_size.height\n\n        # Process all coordinates and group them by their target cell\n        for x, y in coordinates:\n            # Early rejection for out-of-bounds\n            if not self._canvas_region.contains(floor(x), floor(y)):\n                continue\n\n            # Calculate high-res coordinates\n            hx = floor(x * w_factor)\n            hy = floor(y * h_factor)\n\n            # Calculate which cell this belongs to and offset within cell\n            cell_x = hx // w_factor\n            cell_y = hy // h_factor\n\n            # Get or create the set for this cell\n            cell_key = (cell_x, cell_y)\n            if cell_key not in cells_to_update:\n                cells_to_update[cell_key] = set()\n\n            # Add this point to the cell's set\n            offset_x = hx % w_factor\n            offset_y = hy % h_factor\n            cells_to_update[cell_key].add((offset_x, offset_y))\n\n        # Process each cell that needs updating\n        for (cell_x, cell_y), points in cells_to_update.items():\n            # Create a small buffer just for this cell\n            cell_buffer = np.zeros((pixel_size.height, pixel_size.width), dtype=bool)\n\n            # Mark each point in the buffer\n            for offset_x, offset_y in points:\n                cell_buffer[offset_y, offset_x] = True\n\n            # Convert to subpixels and look up the character\n            subpixels = tuple(int(v) for v in cell_buffer.flat)\n            if char := pixel_info[subpixels]:\n                self.set_pixel(\n                    cell_x,\n                    cell_y,\n                    char=char,\n                    style=style,\n                )\n\n    def draw_line(\n        self, x0: int, y0: int, x1: int, y1: int, char: str = \"\u2588\", style: str = \"white\"\n    ) -&gt; None:\n        \"\"\"Draws a line from (x0, y0) to (x1, y1) using the specified character and style.\n\n        Args:\n            x0: The x-coordinate of the start of the line.\n            y0: The y-coordinate of the start of the line.\n            x1: The x-coordinate of the end of the line.\n            y1: The y-coordinate of the end of the line.\n            char: The character to draw.\n            style: The style to apply to the character.\n        \"\"\"\n        if not self._canvas_region.contains(\n            x0, y0\n        ) and not self._canvas_region.contains(x1, y1):\n            return\n        self.set_pixels(self._get_line_coordinates(x0, y0, x1, y1), char, style)\n\n    def draw_lines(\n        self,\n        coordinates: Iterable[tuple[int, int, int, int]],\n        char: str = \"\u2588\",\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draws multiple lines from given coordinates using the specified character and style.\n\n        Args:\n            coordinates: An iterable of tuples representing the coordinates of the lines.\n            char: The character to draw.\n            style: The style to apply to the character.\n        \"\"\"\n        # Convert to list for multiple passes\n        coord_list = list(coordinates)\n        if not coord_list:\n            return\n\n        # Collect all pixels from all lines before rendering\n        all_pixels = []\n\n        for x0, y0, x1, y1 in coord_list:\n            # Skip if both endpoints are outside the canvas\n            if not self._canvas_region.contains(\n                x0, y0\n            ) and not self._canvas_region.contains(x1, y1):\n                continue\n\n            # Get coordinates for this line and extend the pixel collection\n            line_pixels = self._get_line_coordinates(x0, y0, x1, y1)\n            all_pixels.extend(line_pixels)\n\n        # Draw all pixels at once with a single refresh\n        if all_pixels:\n            self.set_pixels(all_pixels, char, style)\n\n    def draw_hires_line(\n        self,\n        x0: float,\n        y0: float,\n        x1: float,\n        y1: float,\n        hires_mode: HiResMode | None = None,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draws a high-resolution line from (x0, y0) to (x1, y1) using the specified character and style.\n\n        Args:\n            x0: The x-coordinate of the start of the line.\n            y0: The y-coordinate of the start of the line.\n            x1: The x-coordinate of the end of the line.\n            y1: The y-coordinate of the end of the line.\n            hires_mode: The high-resolution mode to use.\n            style: The style to apply to the character.\n        \"\"\"\n        self.draw_hires_lines([(x0, y0, x1, y1)], hires_mode, style)\n\n    def draw_hires_lines(\n        self,\n        coordinates: Iterable[\n            tuple[FloatScalar, FloatScalar, FloatScalar, FloatScalar]\n        ],\n        hires_mode: HiResMode | None = None,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draws multiple high-resolution lines from given coordinates using the specified character and style.\n\n        Args:\n            coordinates: An iterable of tuples representing the coordinates of the lines.\n            hires_mode: The high-resolution mode to use.\n            style: The style to apply to the character.\n        \"\"\"\n        # Early out if no coordinates\n        if not coordinates:\n            return\n\n        # Convert to list if not already for multiple passes\n        coord_list = list(coordinates)\n\n        hires_mode = hires_mode or self.default_hires_mode\n        pixel_size = hires_sizes[hires_mode]\n\n        # Pre-compute multiplication factors once\n        w_factor = pixel_size.width\n        h_factor = pixel_size.height\n        inv_w_factor = 1.0 / w_factor\n        inv_h_factor = 1.0 / h_factor\n\n        # Initialize an empty list for collecting pixel coordinates\n        pixels: list[tuple[float, float]] = []\n        pixels_append = pixels.append  # Local reference for faster calls\n\n        # Process each line\n        for x0, y0, x1, y1 in coord_list:\n            # Skip if both endpoints are outside canvas (optimization)\n            if not self._canvas_region.contains(\n                floor(x0), floor(y0)\n            ) and not self._canvas_region.contains(floor(x1), floor(y1)):\n                continue\n\n            # Convert to high-res grid coordinates\n            hx0 = floor(x0 * w_factor)\n            hy0 = floor(y0 * h_factor)\n            hx1 = floor(x1 * w_factor)\n            hy1 = floor(y1 * h_factor)\n\n            # Get line coordinates\n            coords = self._get_line_coordinates(hx0, hy0, hx1, hy1)\n\n            # Convert back to canvas space and add to pixel array\n            # Use direct append and precalculated factors for better performance\n            for x, y in coords:\n                pixels_append((x * inv_w_factor, y * inv_h_factor))\n\n        # Only make one call to set_hires_pixels with all points\n        if pixels:\n            self.set_hires_pixels(pixels, hires_mode, style)\n\n    def draw_triangle(\n        self,\n        x0: int,\n        y0: int,\n        x1: int,\n        y1: int,\n        x2: int,\n        y2: int,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a triangle outline using the specified style.\n\n        Args:\n            x0: The x-coordinate of the first vertex.\n            y0: The y-coordinate of the first vertex.\n            x1: The x-coordinate of the second vertex.\n            y1: The y-coordinate of the second vertex.\n            x2: The x-coordinate of the third vertex.\n            y2: The y-coordinate of the third vertex.\n            style: The style to apply to the characters.\n        \"\"\"\n\n        # Draw the three sides of the triangle\n        self.draw_lines(\n            [(x0, y0, x1, y1), (x1, y1, x2, y2), (x2, y2, x0, y0)], \"\u2588\", style\n        )\n\n    def draw_hires_triangle(\n        self,\n        x0: float,\n        y0: float,\n        x1: float,\n        y1: float,\n        x2: float,\n        y2: float,\n        hires_mode: HiResMode | None = None,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a high-resolution triangle outline using the specified style.\n\n        Args:\n            x0: The x-coordinate of the first vertex.\n            y0: The y-coordinate of the first vertex.\n            x1: The x-coordinate of the second vertex.\n            y1: The y-coordinate of the second vertex.\n            x2: The x-coordinate of the third vertex.\n            y2: The y-coordinate of the third vertex.\n            hires_mode: The high-resolution mode to use.\n            style: The style to apply to the characters.\n        \"\"\"\n\n        # Draw the three sides of the triangle with high-resolution\n        self.draw_hires_lines(\n            [(x0, y0, x1, y1), (x1, y1, x2, y2), (x2, y2, x0, y0)], hires_mode, style\n        )\n\n    def draw_filled_triangle(\n        self,\n        x0: int,\n        y0: int,\n        x1: int,\n        y1: int,\n        x2: int,\n        y2: int,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a filled triangle using the specified style.\n        Uses a scanline algorithm for efficient filling.\n\n        Args:\n            x0: The x-coordinate of the first vertex.\n            y0: The y-coordinate of the first vertex.\n            x1: The x-coordinate of the second vertex.\n            y1: The y-coordinate of the second vertex.\n            x2: The x-coordinate of the third vertex.\n            y2: The y-coordinate of the third vertex.\n            style: The style to apply to the characters.\n        \"\"\"\n        # Sort vertices by y-coordinate (y0 &lt;= y1 &lt;= y2)\n        if y0 &gt; y1:\n            x0, y0, x1, y1 = x1, y1, x0, y0\n        if y1 &gt; y2:\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        if y0 &gt; y1:\n            x0, y0, x1, y1 = x1, y1, x0, y0\n\n        # Skip if all points are the same or triangle has no height\n        if (y0 == y1 == y2) or (y0 == y2):\n            return\n\n        # Initialize empty list for all pixel coordinates\n        pixels: list[tuple[int, int]] = []\n        pixels_append = pixels.append\n\n        # Calculate interpolation factor for the middle point\n        inv_slope02 = (x2 - x0) / (y2 - y0) if y2 != y0 else 0\n\n        # First half of the triangle (bottom flat or top)\n        if y1 == y0:  # Flat top triangle\n            self._fill_flat_top_triangle(x0, y0, x1, y1, x2, y2, pixels_append)\n        elif y1 == y2:  # Flat bottom triangle\n            self._fill_flat_bottom_triangle(x0, y0, x1, y1, x2, y2, pixels_append)\n        else:  # General triangle - split into flat-top and flat-bottom\n            # Calculate the x-coordinate of the point on the long edge that has y = y1\n            x3 = int(x0 + inv_slope02 * (y1 - y0))\n\n            # Fill the flat bottom part\n            self._fill_flat_bottom_triangle(x0, y0, x1, y1, x3, y1, pixels_append)\n\n            # Fill the flat top part\n            self._fill_flat_top_triangle(x1, y1, x3, y1, x2, y2, pixels_append)\n\n        # Draw all pixels at once\n        if pixels:\n            self.set_pixels(pixels, \"\u2588\", style)\n\n    def _fill_flat_bottom_triangle(\n        self,\n        x0: int,\n        y0: int,\n        x1: int,\n        y1: int,\n        x2: int,\n        y1_dup: int,\n        pixels_append: Callable[[tuple[int, int]], None],\n    ) -&gt; None:\n        \"\"\"Helper method to fill a flat-bottom triangle (private method).\"\"\"\n        dx1 = (x1 - x0) / (y1 - y0) if y1 != y0 else 0\n        dx2 = (x2 - x0) / (y1 - y0) if y1 != y0 else 0\n\n        # Initialize scanline coordinates\n        x_start = x_end = float(x0)\n\n        # Scan from top to bottom\n        for y in range(y0, y1 + 1):\n            # Add all pixels in this scanline\n            for x in range(int(x_start), int(x_end) + 1):\n                pixels_append((x, y))\n\n            # Update scanline endpoints\n            x_start += dx1\n            x_end += dx2\n\n    def _fill_flat_top_triangle(\n        self,\n        x0: int,\n        y0: int,\n        x1: int,\n        y0_dup: int,\n        x2: int,\n        y2: int,\n        pixels_append: Callable[[tuple[int, int]], None],\n    ) -&gt; None:\n        \"\"\"Helper method to fill a flat-top triangle (private method).\"\"\"\n        dx1 = (x2 - x0) / (y2 - y0) if y2 != y0 else 0\n        dx2 = (x2 - x1) / (y2 - y0) if y2 != y0 else 0\n\n        # Initialize scanline coordinates\n        x_start = float(x0)\n        x_end = float(x1)\n\n        # Scan from top to bottom\n        for y in range(y0, y2 + 1):\n            # Add all pixels in this scanline\n            for x in range(int(x_start), int(x_end) + 1):\n                pixels_append((x, y))\n\n            # Update scanline endpoints\n            x_start += dx1\n            x_end += dx2\n\n    def draw_filled_hires_triangle(\n        self,\n        x0: float,\n        y0: float,\n        x1: float,\n        y1: float,\n        x2: float,\n        y2: float,\n        hires_mode: HiResMode | None = None,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a filled high-resolution triangle using the specified style.\n        Uses a scanline algorithm with subpixel precision.\n\n        Args:\n            x0: The x-coordinate of the first vertex.\n            y0: The y-coordinate of the first vertex.\n            x1: The x-coordinate of the second vertex.\n            y1: The y-coordinate of the second vertex.\n            x2: The x-coordinate of the third vertex.\n            y2: The y-coordinate of the third vertex.\n            hires_mode: The high-resolution mode to use.\n            style: The style to apply to the characters.\n        \"\"\"\n        # Use default hires mode if none provided\n        hires_mode = hires_mode or self.default_hires_mode\n\n        # Sort vertices by y-coordinate (y0 &lt;= y1 &lt;= y2)\n        if y0 &gt; y1:\n            x0, y0, x1, y1 = x1, y1, x0, y0\n        if y1 &gt; y2:\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        if y0 &gt; y1:\n            x0, y0, x1, y1 = x1, y1, x0, y0\n\n        # Skip if all points are the same or triangle has no height\n        if abs(y0 - y2) &lt; 1e-6:\n            return\n\n        # Initialize pixel collection\n        pixels: list[tuple[float, float]] = []\n        pixels_append = pixels.append\n\n        # Define helper function to add a hi-res pixel\n        def add_hires_pixel(x: float, y: float) -&gt; None:\n            pixels_append((x, y))\n\n        # No edge parameters needed\n\n        # Process based on triangle shape\n        if abs(y1 - y0) &lt; 1e-6:  # Flat top triangle\n            self._fill_flat_top_hires_triangle(x0, y0, x1, y1, x2, y2, add_hires_pixel)\n        elif abs(y1 - y2) &lt; 1e-6:  # Flat bottom triangle\n            self._fill_flat_bottom_hires_triangle(\n                x0, y0, x1, y1, x2, y2, add_hires_pixel\n            )\n        else:  # General triangle - split into flat-top and flat-bottom\n            # Calculate the interpolation factor for the split point\n            t = (y1 - y0) / (y2 - y0)\n\n            # Calculate the x-coordinate of the point on the long edge that has y = y1\n            x3 = x0 + t * (x2 - x0)\n\n            # Fill the flat bottom part\n            self._fill_flat_bottom_hires_triangle(\n                x0, y0, x1, y1, x3, y1, add_hires_pixel\n            )\n\n            # Fill the flat top part\n            self._fill_flat_top_hires_triangle(x1, y1, x3, y1, x2, y2, add_hires_pixel)\n\n        # Draw all hi-res pixels at once\n        if pixels:\n            self.set_hires_pixels(pixels, hires_mode, style)\n\n    def _fill_flat_bottom_hires_triangle(\n        self,\n        x0: float,\n        y0: float,\n        x1: float,\n        y1: float,\n        x2: float,\n        y1_dup: float,\n        add_pixel: Callable[[float, float], None],\n    ) -&gt; None:\n        \"\"\"Helper method to fill a flat-bottom triangle with hi-res precision (private method).\"\"\"\n        # Calculate slopes\n        height = y1 - y0\n        if abs(height) &lt; 1e-6:\n            return\n\n        dx_left = (x1 - x0) / height\n        dx_right = (x2 - x0) / height\n\n        # Initialize scanline endpoints\n        x_left = x0\n        x_right = x0\n\n        # Calculate steps for smoother rendering (use more y steps for better quality)\n        y_steps = max(100, int(height * 10))\n        y_step = height / y_steps\n\n        # Scan from top to bottom\n        for i in range(y_steps + 1):\n            y = y0 + i * y_step\n\n            # Calculate scanline width\n            width = x_right - x_left\n\n            # Calculate steps for this scanline\n            x_steps = max(20, int(width * 10))\n            x_step = width / max(1, x_steps)\n\n            # Add pixels along scanline\n            for j in range(x_steps + 1):\n                x = x_left + j * x_step\n                add_pixel(x, y)\n\n            # Update scanline endpoints for next row\n            x_left += dx_left * y_step\n            x_right += dx_right * y_step\n\n    def _fill_flat_top_hires_triangle(\n        self,\n        x0: float,\n        y0: float,\n        x1: float,\n        y0_dup: float,\n        x2: float,\n        y2: float,\n        add_pixel: Callable[[float, float], None],\n    ) -&gt; None:\n        \"\"\"Helper method to fill a flat-top triangle with hi-res precision (private method).\"\"\"\n        # Calculate slopes\n        height = y2 - y0\n        if abs(height) &lt; 1e-6:\n            return\n\n        dx_left = (x2 - x0) / height\n        dx_right = (x2 - x1) / height\n\n        # Initialize scanline endpoints\n        x_left = x0\n        x_right = x1\n\n        # Calculate steps for smoother rendering (use more y steps for better quality)\n        y_steps = max(100, int(height * 10))\n        y_step = height / y_steps\n\n        # Scan from top to bottom\n        for i in range(y_steps + 1):\n            y = y0 + i * y_step\n\n            # Calculate scanline width\n            width = x_right - x_left\n\n            # Calculate steps for this scanline\n            x_steps = max(20, int(width * 10))\n            x_step = width / max(1, x_steps)\n\n            # Add pixels along scanline\n            for j in range(x_steps + 1):\n                x = x_left + j * x_step\n                add_pixel(x, y)\n\n            # Update scanline endpoints for next row\n            x_left += dx_left * y_step\n            x_right += dx_right * y_step\n\n    def draw_quad(\n        self,\n        x0: int,\n        y0: int,\n        x1: int,\n        y1: int,\n        x2: int,\n        y2: int,\n        x3: int,\n        y3: int,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a quadrilateral outline using the specified style.\n\n        Args:\n            x0: The x-coordinate of the first vertex.\n            y0: The y-coordinate of the first vertex.\n            x1: The x-coordinate of the second vertex.\n            y1: The y-coordinate of the second vertex.\n            x2: The x-coordinate of the third vertex.\n            y2: The y-coordinate of the third vertex.\n            x3: The x-coordinate of the fourth vertex.\n            y3: The y-coordinate of the fourth vertex.\n            style: The style to apply to the characters.\n        \"\"\"\n        # Draw the four sides of the quadrilateral\n        self.draw_lines(\n            [(x0, y0, x1, y1), (x1, y1, x2, y2), (x2, y2, x3, y3), (x3, y3, x0, y0)],\n            \"\u2588\",\n            style,\n        )\n\n    def draw_hires_quad(\n        self,\n        x0: float,\n        y0: float,\n        x1: float,\n        y1: float,\n        x2: float,\n        y2: float,\n        x3: float,\n        y3: float,\n        hires_mode: HiResMode | None = None,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a high-resolution quadrilateral outline using the specified style.\n\n        Args:\n            x0: The x-coordinate of the first vertex.\n            y0: The y-coordinate of the first vertex.\n            x1: The x-coordinate of the second vertex.\n            y1: The y-coordinate of the second vertex.\n            x2: The x-coordinate of the third vertex.\n            y2: The y-coordinate of the third vertex.\n            x3: The x-coordinate of the fourth vertex.\n            y3: The y-coordinate of the fourth vertex.\n            hires_mode: The high-resolution mode to use.\n            style: The style to apply to the characters.\n        \"\"\"\n        # Draw the four sides of the quadrilateral with high-resolution\n        self.draw_hires_lines(\n            [(x0, y0, x1, y1), (x1, y1, x2, y2), (x2, y2, x3, y3), (x3, y3, x0, y0)],\n            hires_mode,\n            style,\n        )\n\n    def draw_filled_quad(\n        self,\n        x0: int,\n        y0: int,\n        x1: int,\n        y1: int,\n        x2: int,\n        y2: int,\n        x3: int,\n        y3: int,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a filled quadrilateral using the specified style.\n        Splits the quad into two triangles for filling.\n\n        Args:\n            x0: The x-coordinate of the first vertex.\n            y0: The y-coordinate of the first vertex.\n            x1: The x-coordinate of the second vertex.\n            y1: The y-coordinate of the second vertex.\n            x2: The x-coordinate of the third vertex.\n            y2: The y-coordinate of the third vertex.\n            x3: The x-coordinate of the fourth vertex.\n            y3: The y-coordinate of the fourth vertex.\n            style: The style to apply to the characters.\n        \"\"\"\n        # Draw the quad as two filled triangles\n        # First triangle (0, 1, 2)\n        self.draw_filled_triangle(x0, y0, x1, y1, x2, y2, style)\n        # Second triangle (0, 2, 3)\n        self.draw_filled_triangle(x0, y0, x2, y2, x3, y3, style)\n\n    def draw_filled_hires_quad(\n        self,\n        x0: float,\n        y0: float,\n        x1: float,\n        y1: float,\n        x2: float,\n        y2: float,\n        x3: float,\n        y3: float,\n        hires_mode: HiResMode | None = None,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a filled high-resolution quadrilateral using the specified style.\n        Splits the quad into two triangles for filling.\n\n        Args:\n            x0: The x-coordinate of the first vertex.\n            y0: The y-coordinate of the first vertex.\n            x1: The x-coordinate of the second vertex.\n            y1: The y-coordinate of the second vertex.\n            x2: The x-coordinate of the third vertex.\n            y2: The y-coordinate of the third vertex.\n            x3: The x-coordinate of the fourth vertex.\n            y3: The y-coordinate of the fourth vertex.\n            hires_mode: The high-resolution mode to use.\n            style: The style to apply to the characters.\n        \"\"\"\n        # Draw the quad as two filled high-resolution triangles\n        # First triangle (0, 1, 2)\n        self.draw_filled_hires_triangle(x0, y0, x1, y1, x2, y2, hires_mode, style)\n        # Second triangle (0, 2, 3)\n        self.draw_filled_hires_triangle(x0, y0, x2, y2, x3, y3, hires_mode, style)\n\n    def draw_rectangle_box(\n        self,\n        x0: int,\n        y0: int,\n        x1: int,\n        y1: int,\n        thickness: int = 1,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a rectangle box with the specified thickness and style.\n\n        Args:\n            x0: The x-coordinate of the top-left corner.\n            y0: The y-coordinate of the top-left corner.\n            x1: The x-coordinate of the bottom-right corner.\n            y1: The y-coordinate of the bottom-right corner.\n            thickness: The thickness of the box.\n            style: The style to apply to the characters.\n        \"\"\"\n        # (x0, y0)     (x1, y0)\n        #    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        #    \u2502            \u2502\n        #    \u2502            \u2502\n        #    \u2502            \u2502\n        #    \u2502            \u2502\n        #    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        # (x0, y1)     (x1, y1)\n\n        # NOTE: A difference of 0 between coordinates results in a\n        # width or height of 1 cell inside Textual.\n\n        T = thickness\n        x0, x1 = sorted((x0, x1))\n        y0, y1 = sorted((y0, y1))\n\n        # Both width and height are 1. This would just be a dot, so\n        # we don't draw anything.\n        if (x1 - x0 == 0) and (y1 - y0 == 0):\n            return\n\n        # We now know either the width or height must be higher than 2.\n        # Height is 1, place two horizontal line enders.\n        if y1 - y0 == 0:\n            self.set_pixel(x0, y0, char=get_box((0, T, 0, 0)), style=style)\n            self.set_pixel(x1, y0, char=get_box((0, 0, 0, T)), style=style)\n            if x1 - x0 &gt;= 2:\n                # Width is greater than or equal to 3, draw a horizontal line\n                # between the line enders.\n                self.draw_line(\n                    x0 + 1, y0, x1 - 1, y1, char=get_box((0, T, 0, T)), style=style\n                )\n            return\n\n        # Width is 1, place two vertical line enders.\n        if x1 - x0 == 0:\n            self.set_pixel(x0, y0, char=get_box((0, 0, T, 0)), style=style)\n            self.set_pixel(x0, y1, char=get_box((T, 0, 0, 0)), style=style)\n            if y1 - y0 &gt;= 2:\n                # Height is greater than or equal to 3, draw a horizontal line\n                # between the line enders.\n                self.draw_line(\n                    x0, y0 + 1, x1, y1 - 1, char=get_box((T, 0, T, 0)), style=style\n                )\n            return\n\n        # The remaining conditions require all the corner pieces to be drawn.\n        self.set_pixel(x0, y0, char=get_box((0, T, T, 0)), style=style)\n        self.set_pixel(x1, y0, char=get_box((0, 0, T, T)), style=style)\n        self.set_pixel(x1, y1, char=get_box((T, 0, 0, T)), style=style)\n        self.set_pixel(x0, y1, char=get_box((T, T, 0, 0)), style=style)\n\n        # If width and height are both 2, we don't need any lines. Only corners.\n        if (x1 - x0 == 1) and (y1 - y0 == 1):\n            return\n\n        # Width is greater than or equal to 3, draw horizontal lines.\n        if x1 - x0 &gt;= 2:\n            for y in y0, y1:\n                self.draw_line(\n                    x0 + 1, y, x1 - 1, y, char=get_box((0, T, 0, T)), style=style\n                )\n        # Height is greater than or equal to 3, draw vertical lines.\n        if y1 - y0 &gt;= 2:\n            for x in x0, x1:\n                self.draw_line(\n                    x, y0 + 1, x, y1 - 1, char=get_box((T, 0, T, 0)), style=style\n                )\n\n    def draw_filled_circle(\n        self, cx: int, cy: int, radius: int, style: str = \"white\"\n    ) -&gt; None:\n        \"\"\"Draw a filled circle using Bresenham's algorithm. Compensates for 2:1 aspect ratio.\n\n        Args:\n            cx (int): X-coordinate of the center of the circle.\n            cy (int): Y-coordinate of the center of the circle.\n            radius (int): Radius of the circle.\n            style (str): Style of the pixels to be drawn.\n        \"\"\"\n        # Early rejection for invalid inputs\n        if radius &lt;= 0:\n            return\n\n        # Initialize buffer to collect all pixels\n        pixels: list[tuple[int, int]] = []\n        pixels_append = pixels.append  # Local reference for faster calls\n\n        x = 0\n        y = radius\n        d = 3 - 2 * radius\n\n        # Pre-compute aspect ratio adjustments\n        max_iterations = radius * 2  # Safety limit\n        iteration = 0\n\n        while y &gt;= x and iteration &lt; max_iterations:\n            # Adjust y-coordinates to account for 2:1 aspect ratio\n            y1 = cy + (y + 1) // 2\n            y2 = cy + (x + 1) // 2\n            y3 = cy - x // 2\n            y4 = cy - y // 2\n\n            # Add horizontal lines of pixels\n            for xpos in range(cx - x, cx + x + 1):\n                pixels_append((xpos, y1))\n                pixels_append((xpos, y4))\n\n            for xpos in range(cx - y, cx + y + 1):\n                pixels_append((xpos, y2))\n                pixels_append((xpos, y3))\n\n            x += 1\n            if d &gt; 0:\n                y -= 1\n                d = d + 4 * (x - y) + 10\n            else:\n                d = d + 4 * x + 6\n\n            iteration += 1\n\n        # Draw all pixels at once\n        if pixels:\n            self.set_pixels(pixels, \"\u2588\", style)\n\n    def draw_filled_hires_circle(\n        self,\n        cx: float,\n        cy: float,\n        radius: float,\n        hires_mode: HiResMode | None = None,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a filled circle, with high-resolution support.\n\n        Args:\n            cx (float): X-coordinate of the center of the circle.\n            cy (float): Y-coordinate of the center of the circle.\n            radius (float): Radius of the circle.\n            hires_mode (HiResMode): The high-resolution mode to use.\n            style (str): Style of the pixels to be drawn.\n        \"\"\"\n        # Early rejection for invalid inputs\n        if radius &lt;= 0:\n            return\n\n        # Constants and scaling factors\n        scale_x = 1\n        scale_y = 2\n        aspect_ratio = scale_x / scale_y\n\n        # Pre-compute values used in the inner loop\n        radius_squared = radius**2\n        inv_scale_x = 1.0 / scale_x\n        inv_scale_y_aspect = 1.0 / (scale_y * aspect_ratio)\n\n        # Determine the bounding box for the circle\n        y_min = int(-radius * scale_y)\n        y_max = int(radius * scale_y) + 1\n        x_min = int(-radius * scale_x)\n        x_max = int(radius * scale_x) + 1\n\n        # Initialize an empty list for collecting pixel coordinates\n        # (We calculate estimated_pixels only for the safety check below)\n        estimated_pixels = int(3.2 * radius * radius)  # 3.2 instead of \u03c0 for safety\n        pixels: list[tuple[float, float]] = []\n        pixels_append = pixels.append  # Local reference for faster calls\n\n        # Use a more efficient scanning algorithm\n        # For each y, compute the range of valid x values directly\n        for y in range(y_min, y_max):\n            # Solve circle equation for x: (x/sx)\u00b2 + (y/(sy*ar))\u00b2 &lt;= r\u00b2\n            y_term = (y * inv_scale_y_aspect) ** 2\n            if y_term &gt; radius_squared:\n                continue  # Skip this row if y is outside the circle\n\n            x_term_max = radius_squared - y_term\n            if x_term_max &lt; 0:\n                continue  # Skip if no valid x values\n\n            # Find the range of valid x values\n            x_radius = int((x_term_max**0.5) * scale_x)\n            x_start = max(x_min, -x_radius)\n            x_end = min(x_max, x_radius + 1)\n\n            # Add all points in this row in one go\n            for x in range(x_start, x_end):\n                pixels_append((cx + x * inv_scale_x, cy + y / scale_y))\n\n            # Safety check\n            if len(pixels) &gt; estimated_pixels * 2:\n                break\n\n        # Render all pixels at once\n        self.set_hires_pixels(pixels, hires_mode, style)\n\n    def draw_circle(self, cx: int, cy: int, radius: int, style: str = \"white\") -&gt; None:\n        \"\"\"Draw a circle using Bresenham's algorithm. Compensates for 2:1 aspect ratio.\n\n        Args:\n            cx (int): X-coordinate of the center of the circle.\n            cy (int): Y-coordinate of the center of the circle.\n            radius (int): Radius of the circle.\n            style (str): Style of the pixels to be drawn.\n        \"\"\"\n        # Early rejection for invalid inputs\n        if radius &lt;= 0:\n            return\n\n        # Initialize buffer to collect all pixels\n        pixels: list[tuple[int, int]] = []\n        pixels_append = pixels.append  # Local reference for faster calls\n\n        x = radius\n        y = 0\n        decision = 1 - radius\n\n        # Pre-compute aspect ratio adjustments\n        max_iterations = radius * 2  # Safety limit\n        iteration = 0\n\n        while y &lt;= x and iteration &lt; max_iterations:\n            y_half = y // 2\n            x_half = x // 2\n\n            # Add all 8 points in each octant\n            pixels_append((cx + x, cy + y_half))\n            pixels_append((cx - x, cy + y_half))\n            pixels_append((cx + x, cy - y_half))\n            pixels_append((cx - x, cy - y_half))\n            pixels_append((cx + y, cy + x_half))\n            pixels_append((cx - y, cy + x_half))\n            pixels_append((cx + y, cy - x_half))\n            pixels_append((cx - y, cy - x_half))\n\n            y += 1\n            if decision &lt;= 0:\n                decision += 2 * y + 1\n            else:\n                x -= 1\n                decision += 2 * (y - x) + 1\n\n            iteration += 1\n\n        # Draw all pixels at once\n        if pixels:\n            self.set_pixels(pixels, \"\u2588\", style)\n\n    def draw_hires_circle(\n        self,\n        cx: float,\n        cy: float,\n        radius: float,\n        hires_mode: HiResMode | None = None,\n        style: str = \"white\",\n    ) -&gt; None:\n        \"\"\"Draw a circle with high-resolution support using Bresenham's algorithm. Compensates for 2:1 aspect ratio.\n\n        Args:\n            cx (float): X-coordinate of the center of the circle.\n            cy (float): Y-coordinate of the center of the circle.\n            radius (float): Radius of the circle.\n            hires_mode (HiResMode): The high-resolution mode to use.\n            style (str): Style of the pixels to be drawn.\n        \"\"\"\n        # Early rejection for invalid inputs\n        if radius &lt;= 0:\n            return\n\n        # Initialize an empty list for collecting pixel coordinates\n        # (We calculate estimated_size only for the safety check below)\n        estimated_size = int(\n            radius * 16\n        )  # Each step adds 8 pixels, estimate 4*radius steps\n        pixels: list[tuple[float, float]] = []\n        pixels_extend = pixels.extend  # Local reference for faster calls\n\n        # Pre-compute constants\n        scale_x = 1\n        scale_y = 2\n        aspect_ratio = scale_x / scale_y\n\n        # Midpoint circle algorithm with floating point precision\n        x: float = radius\n        y: float = 0\n        decision: float = 1 - radius\n\n        # Pre-compute points for each octant to avoid repeated calculations\n        def get_circle_points(x: float, y: float) -&gt; list[tuple[float, float]]:\n            y_scaled = y * aspect_ratio\n            x_scaled = x * aspect_ratio\n            return [\n                (cx + x, cy + y_scaled),\n                (cx - x, cy + y_scaled),\n                (cx + x, cy - y_scaled),\n                (cx - x, cy - y_scaled),\n                (cx + y, cy + x_scaled),\n                (cx - y, cy + x_scaled),\n                (cx + y, cy - x_scaled),\n                (cx - y, cy - x_scaled),\n            ]\n\n        # Generate points for the circle\n        while y &lt;= x:\n            # Add all 8 points at once\n            pixels_extend(get_circle_points(x, y))\n\n            # Update position\n            y += 0.5\n            if decision &lt;= 0:\n                decision += 2 * y + 1\n            else:\n                x -= 0.5\n                decision += 2 * (y - x) + 1\n\n            # Safety check to avoid infinite loops\n            if len(pixels) &gt; estimated_size:\n                break\n\n        # Render all pixels at once\n        self.set_hires_pixels(pixels, hires_mode, style)\n\n    def write_text(\n        self,\n        x: int,\n        y: int,\n        text: str,\n        align: TextAlign = TextAlign.LEFT,\n    ) -&gt; None:\n        \"\"\"Write text to the canvas at the specified position, with support for markup.\n\n        Args:\n            x (int): X-coordinate of the left edge of the text.\n            y (int): Y-coordinate of the baseline of the text.\n            text (str): Text to be written.\n            align (TextAlign): The alignment of the text within the canvas.\n        \"\"\"\n        if y &lt; 0 or y &gt;= self._canvas_size.height:\n            return\n\n        # parse markup\n        rich_text = Text.from_markup(text)\n        # store plain text\n        if (plain_text := rich_text.plain) == \"\":\n            return\n        # store styles for each individual character\n        rich_styles = []\n        for c in rich_text.divide(range(1, len(plain_text))):\n            style = Style()\n            for span in c._spans:\n                style += Style.parse(span.style)\n            rich_styles.append(style)\n\n        if align == TextAlign.RIGHT:\n            x -= len(plain_text) - 1\n        elif align == TextAlign.CENTER:\n            div, mod = divmod(len(plain_text), 2)\n            x -= div\n            if mod == 0:\n                # even number of characters, shift one to the right since I just\n                # like that better -- DF\n                x += 1\n\n        if x &lt;= -len(plain_text) or x &gt;= self._canvas_size.width:\n            # no part of text falls inside the canvas\n            return\n\n        overflow_left = -x\n        overflow_right = x + len(plain_text) - self._canvas_size.width\n        if overflow_left &gt; 0:\n            buffer_left = 0\n            text_left = overflow_left\n        else:\n            buffer_left = x\n            text_left = 0\n        if overflow_right &gt; 0:\n            buffer_right = None\n            text_right = -overflow_right\n        else:\n            buffer_right = x + len(plain_text)\n            text_right = None\n\n        self._buffer[y][buffer_left:buffer_right] = plain_text[text_left:text_right]\n        self._styles[y][buffer_left:buffer_right] = [\n            str(s) for s in rich_styles[text_left:text_right]\n        ]\n        assert len(self._buffer[y]) == self._canvas_size.width\n        assert len(self._styles[y]) == self._canvas_size.width\n        self.refresh()\n\n    def _get_line_coordinates(\n        self, x0: int, y0: int, x1: int, y1: int\n    ) -&gt; list[tuple[int, int]]:\n        \"\"\"Get all pixel coordinates on the line between two points.\n\n        Fast implementation of Bresenham's line algorithm.\n        Returns a list of coordinates instead of a generator for better performance.\n\n        Args:\n            x0: starting point x coordinate\n            y0: starting point y coordinate\n            x1: end point x coordinate\n            y1: end point y coordinate\n\n        Returns:\n            List of (x, y) coordinate tuples that make up the line.\n        \"\"\"\n        # Early rejection if endpoints are identical\n        if x0 == x1 and y0 == y1:\n            return [(x0, y0)]\n\n        # Fast path for horizontal lines\n        if y0 == y1:\n            if x0 &lt; x1:\n                return [(x, y0) for x in range(x0, x1 + 1)]\n            else:\n                return [(x, y0) for x in range(x1, x0 + 1)]\n\n        # Fast path for vertical lines\n        if x0 == x1:\n            if y0 &lt; y1:\n                return [(x0, y) for y in range(y0, y1 + 1)]\n            else:\n                return [(x0, y) for y in range(y1, y0 + 1)]\n\n        # Initialize algorithm variables\n        dx = abs(x1 - x0)\n        sx = 1 if x0 &lt; x1 else -1\n        dy = -abs(y1 - y0)\n        sy = 1 if y0 &lt; y1 else -1\n        error = dx + dy\n\n        # Pre-allocate result list with known line length for efficiency\n        # The +1 ensures we have enough space for all points\n        max_points = max(abs(x1 - x0), abs(y1 - y0)) + 1\n        points = []\n        points.append((x0, y0))\n\n        # x and y are mutable copies so we can modify them\n        x, y = x0, y0\n\n        # Main loop - more efficient without generator overhead\n        while not (x == x1 and y == y1):\n            e2 = 2 * error\n            if e2 &gt;= dy:\n                if x == x1:\n                    break\n                error += dy\n                x += sx\n            if e2 &lt;= dx:\n                if y == y1:\n                    break\n                error += dx\n                y += sy\n            points.append((x, y))\n\n            # Safety check to avoid infinite loops\n            if len(points) &gt; max_points:\n                break\n\n        return points\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.__init__","title":"<code>__init__(width=40, height=20, default_hires_mode=HiResMode.BRAILLE, name=None, id=None, classes=None, disabled=False)</code>","text":"<p>Initialize the Canvas widget.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the canvas. Defaults to 40.</p> <code>40</code> <code>height</code> <code>int</code> <p>The height of the canvas. Defaults to 20.</p> <code>20</code> <code>default_hires_mode</code> <code>HiResMode | None</code> <p>The default high-resolution mode. Defaults to HiresMode.BRAILLE.</p> <code>BRAILLE</code> <code>name</code> <code>str | None</code> <p>The name of the widget. Defaults to None.</p> <code>None</code> <code>id</code> <code>str | None</code> <p>The ID of the widget. Defaults to None.</p> <code>None</code> <code>classes</code> <code>str | None</code> <p>The CSS classes of the widget. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the widget is disabled. Defaults to False.</p> <code>False</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def __init__(\n    self,\n    width: int = 40,\n    height: int = 20,\n    default_hires_mode: HiResMode | None = HiResMode.BRAILLE,\n    name: str | None = None,\n    id: str | None = None,\n    classes: str | None = None,\n    disabled: bool = False,\n):\n    \"\"\"Initialize the Canvas widget.\n\n    Args:\n        width: The width of the canvas. Defaults to 40.\n        height: The height of the canvas. Defaults to 20.\n        default_hires_mode: The default high-resolution mode. Defaults to\n            HiresMode.BRAILLE.\n        name: The name of the widget. Defaults to None.\n        id: The ID of the widget. Defaults to None.\n        classes: The CSS classes of the widget. Defaults to None.\n        disabled: Whether the widget is disabled. Defaults to False.\n    \"\"\"\n    super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n\n    self._refreshes_pending: int = 0\n    # reference count batch refreshes\n\n    self._buffer = []\n    self._styles = []\n    self._canvas_size = Size(0, 0)\n    self._canvas_region = Region()\n\n    self.default_hires_mode = default_hires_mode or HiResMode.BRAILLE\n\n    self.reset(size=Size(width, height), refresh=False)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.async_batch_refresh","title":"<code>async_batch_refresh()</code>  <code>async</code>","text":"<p>Async context manager that defers call to refresh until exiting the context.</p> <p>This is useful when making multiple asynchronous changes to the canvas and only wanting to trigger refresh once at the end.</p> Example <p>Yields:</p> <p>AsyncIterator[None]: An async context manager.</p> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>@asynccontextmanager\nasync def async_batch_refresh(self) -&gt; AsyncIterator[None]:\n    \"\"\"Async context manager that defers call to refresh until exiting the context.\n\n    This is useful when making multiple asynchronous changes to the canvas and only wanting\n    to trigger refresh once at the end.\n\n    Example:\n            Yields:\n    AsyncIterator[None]: An async context manager.\n    \"\"\"\n    self._refreshes_pending += 1\n    try:\n        yield\n    finally:\n        self._refreshes_pending -= 1\n        if self._refreshes_pending == 0:\n            self.refresh()\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.batch_refresh","title":"<code>batch_refresh()</code>","text":"<p>Context manager that defers call to refresh until exiting the context.</p> <p>This is useful when making multiple changes to the canvas and only wanting to trigger refresh once at the end.</p> Example <pre><code>with canvas.batch_changes():\n    canvas.set_pixel(0, 0)\n    canvas.set_pixel(1, 1)\n    canvas.set_pixel(2, 2)\n# Refresh called\n</code></pre> <p>Yields:</p> Type Description <code>None</code> <p>Iterator[None]: A context manager.</p> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>@contextmanager\ndef batch_refresh(self) -&gt; Iterator[None]:\n    \"\"\"Context manager that defers call to refresh until exiting the context.\n\n    This is useful when making multiple changes to the canvas and only wanting\n    to trigger refresh once at the end.\n\n    Example:\n        ```python\n        with canvas.batch_changes():\n            canvas.set_pixel(0, 0)\n            canvas.set_pixel(1, 1)\n            canvas.set_pixel(2, 2)\n        # Refresh called\n        ```\n\n    Yields:\n        Iterator[None]: A context manager.\n    \"\"\"\n    self._refreshes_pending += 1\n    try:\n        yield\n    finally:\n        self._refreshes_pending -= 1\n        if self._refreshes_pending == 0:\n            self.refresh()\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_circle","title":"<code>draw_circle(cx, cy, radius, style='white')</code>","text":"<p>Draw a circle using Bresenham's algorithm. Compensates for 2:1 aspect ratio.</p> <p>Parameters:</p> Name Type Description Default <code>cx</code> <code>int</code> <p>X-coordinate of the center of the circle.</p> required <code>cy</code> <code>int</code> <p>Y-coordinate of the center of the circle.</p> required <code>radius</code> <code>int</code> <p>Radius of the circle.</p> required <code>style</code> <code>str</code> <p>Style of the pixels to be drawn.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_circle(self, cx: int, cy: int, radius: int, style: str = \"white\") -&gt; None:\n    \"\"\"Draw a circle using Bresenham's algorithm. Compensates for 2:1 aspect ratio.\n\n    Args:\n        cx (int): X-coordinate of the center of the circle.\n        cy (int): Y-coordinate of the center of the circle.\n        radius (int): Radius of the circle.\n        style (str): Style of the pixels to be drawn.\n    \"\"\"\n    # Early rejection for invalid inputs\n    if radius &lt;= 0:\n        return\n\n    # Initialize buffer to collect all pixels\n    pixels: list[tuple[int, int]] = []\n    pixels_append = pixels.append  # Local reference for faster calls\n\n    x = radius\n    y = 0\n    decision = 1 - radius\n\n    # Pre-compute aspect ratio adjustments\n    max_iterations = radius * 2  # Safety limit\n    iteration = 0\n\n    while y &lt;= x and iteration &lt; max_iterations:\n        y_half = y // 2\n        x_half = x // 2\n\n        # Add all 8 points in each octant\n        pixels_append((cx + x, cy + y_half))\n        pixels_append((cx - x, cy + y_half))\n        pixels_append((cx + x, cy - y_half))\n        pixels_append((cx - x, cy - y_half))\n        pixels_append((cx + y, cy + x_half))\n        pixels_append((cx - y, cy + x_half))\n        pixels_append((cx + y, cy - x_half))\n        pixels_append((cx - y, cy - x_half))\n\n        y += 1\n        if decision &lt;= 0:\n            decision += 2 * y + 1\n        else:\n            x -= 1\n            decision += 2 * (y - x) + 1\n\n        iteration += 1\n\n    # Draw all pixels at once\n    if pixels:\n        self.set_pixels(pixels, \"\u2588\", style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_filled_circle","title":"<code>draw_filled_circle(cx, cy, radius, style='white')</code>","text":"<p>Draw a filled circle using Bresenham's algorithm. Compensates for 2:1 aspect ratio.</p> <p>Parameters:</p> Name Type Description Default <code>cx</code> <code>int</code> <p>X-coordinate of the center of the circle.</p> required <code>cy</code> <code>int</code> <p>Y-coordinate of the center of the circle.</p> required <code>radius</code> <code>int</code> <p>Radius of the circle.</p> required <code>style</code> <code>str</code> <p>Style of the pixels to be drawn.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_filled_circle(\n    self, cx: int, cy: int, radius: int, style: str = \"white\"\n) -&gt; None:\n    \"\"\"Draw a filled circle using Bresenham's algorithm. Compensates for 2:1 aspect ratio.\n\n    Args:\n        cx (int): X-coordinate of the center of the circle.\n        cy (int): Y-coordinate of the center of the circle.\n        radius (int): Radius of the circle.\n        style (str): Style of the pixels to be drawn.\n    \"\"\"\n    # Early rejection for invalid inputs\n    if radius &lt;= 0:\n        return\n\n    # Initialize buffer to collect all pixels\n    pixels: list[tuple[int, int]] = []\n    pixels_append = pixels.append  # Local reference for faster calls\n\n    x = 0\n    y = radius\n    d = 3 - 2 * radius\n\n    # Pre-compute aspect ratio adjustments\n    max_iterations = radius * 2  # Safety limit\n    iteration = 0\n\n    while y &gt;= x and iteration &lt; max_iterations:\n        # Adjust y-coordinates to account for 2:1 aspect ratio\n        y1 = cy + (y + 1) // 2\n        y2 = cy + (x + 1) // 2\n        y3 = cy - x // 2\n        y4 = cy - y // 2\n\n        # Add horizontal lines of pixels\n        for xpos in range(cx - x, cx + x + 1):\n            pixels_append((xpos, y1))\n            pixels_append((xpos, y4))\n\n        for xpos in range(cx - y, cx + y + 1):\n            pixels_append((xpos, y2))\n            pixels_append((xpos, y3))\n\n        x += 1\n        if d &gt; 0:\n            y -= 1\n            d = d + 4 * (x - y) + 10\n        else:\n            d = d + 4 * x + 6\n\n        iteration += 1\n\n    # Draw all pixels at once\n    if pixels:\n        self.set_pixels(pixels, \"\u2588\", style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_filled_hires_circle","title":"<code>draw_filled_hires_circle(cx, cy, radius, hires_mode=None, style='white')</code>","text":"<p>Draw a filled circle, with high-resolution support.</p> <p>Parameters:</p> Name Type Description Default <code>cx</code> <code>float</code> <p>X-coordinate of the center of the circle.</p> required <code>cy</code> <code>float</code> <p>Y-coordinate of the center of the circle.</p> required <code>radius</code> <code>float</code> <p>Radius of the circle.</p> required <code>hires_mode</code> <code>HiResMode</code> <p>The high-resolution mode to use.</p> <code>None</code> <code>style</code> <code>str</code> <p>Style of the pixels to be drawn.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_filled_hires_circle(\n    self,\n    cx: float,\n    cy: float,\n    radius: float,\n    hires_mode: HiResMode | None = None,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a filled circle, with high-resolution support.\n\n    Args:\n        cx (float): X-coordinate of the center of the circle.\n        cy (float): Y-coordinate of the center of the circle.\n        radius (float): Radius of the circle.\n        hires_mode (HiResMode): The high-resolution mode to use.\n        style (str): Style of the pixels to be drawn.\n    \"\"\"\n    # Early rejection for invalid inputs\n    if radius &lt;= 0:\n        return\n\n    # Constants and scaling factors\n    scale_x = 1\n    scale_y = 2\n    aspect_ratio = scale_x / scale_y\n\n    # Pre-compute values used in the inner loop\n    radius_squared = radius**2\n    inv_scale_x = 1.0 / scale_x\n    inv_scale_y_aspect = 1.0 / (scale_y * aspect_ratio)\n\n    # Determine the bounding box for the circle\n    y_min = int(-radius * scale_y)\n    y_max = int(radius * scale_y) + 1\n    x_min = int(-radius * scale_x)\n    x_max = int(radius * scale_x) + 1\n\n    # Initialize an empty list for collecting pixel coordinates\n    # (We calculate estimated_pixels only for the safety check below)\n    estimated_pixels = int(3.2 * radius * radius)  # 3.2 instead of \u03c0 for safety\n    pixels: list[tuple[float, float]] = []\n    pixels_append = pixels.append  # Local reference for faster calls\n\n    # Use a more efficient scanning algorithm\n    # For each y, compute the range of valid x values directly\n    for y in range(y_min, y_max):\n        # Solve circle equation for x: (x/sx)\u00b2 + (y/(sy*ar))\u00b2 &lt;= r\u00b2\n        y_term = (y * inv_scale_y_aspect) ** 2\n        if y_term &gt; radius_squared:\n            continue  # Skip this row if y is outside the circle\n\n        x_term_max = radius_squared - y_term\n        if x_term_max &lt; 0:\n            continue  # Skip if no valid x values\n\n        # Find the range of valid x values\n        x_radius = int((x_term_max**0.5) * scale_x)\n        x_start = max(x_min, -x_radius)\n        x_end = min(x_max, x_radius + 1)\n\n        # Add all points in this row in one go\n        for x in range(x_start, x_end):\n            pixels_append((cx + x * inv_scale_x, cy + y / scale_y))\n\n        # Safety check\n        if len(pixels) &gt; estimated_pixels * 2:\n            break\n\n    # Render all pixels at once\n    self.set_hires_pixels(pixels, hires_mode, style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_filled_hires_quad","title":"<code>draw_filled_hires_quad(x0, y0, x1, y1, x2, y2, x3, y3, hires_mode=None, style='white')</code>","text":"<p>Draw a filled high-resolution quadrilateral using the specified style. Splits the quad into two triangles for filling.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>float</code> <p>The x-coordinate of the first vertex.</p> required <code>y0</code> <code>float</code> <p>The y-coordinate of the first vertex.</p> required <code>x1</code> <code>float</code> <p>The x-coordinate of the second vertex.</p> required <code>y1</code> <code>float</code> <p>The y-coordinate of the second vertex.</p> required <code>x2</code> <code>float</code> <p>The x-coordinate of the third vertex.</p> required <code>y2</code> <code>float</code> <p>The y-coordinate of the third vertex.</p> required <code>x3</code> <code>float</code> <p>The x-coordinate of the fourth vertex.</p> required <code>y3</code> <code>float</code> <p>The y-coordinate of the fourth vertex.</p> required <code>hires_mode</code> <code>HiResMode | None</code> <p>The high-resolution mode to use.</p> <code>None</code> <code>style</code> <code>str</code> <p>The style to apply to the characters.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_filled_hires_quad(\n    self,\n    x0: float,\n    y0: float,\n    x1: float,\n    y1: float,\n    x2: float,\n    y2: float,\n    x3: float,\n    y3: float,\n    hires_mode: HiResMode | None = None,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a filled high-resolution quadrilateral using the specified style.\n    Splits the quad into two triangles for filling.\n\n    Args:\n        x0: The x-coordinate of the first vertex.\n        y0: The y-coordinate of the first vertex.\n        x1: The x-coordinate of the second vertex.\n        y1: The y-coordinate of the second vertex.\n        x2: The x-coordinate of the third vertex.\n        y2: The y-coordinate of the third vertex.\n        x3: The x-coordinate of the fourth vertex.\n        y3: The y-coordinate of the fourth vertex.\n        hires_mode: The high-resolution mode to use.\n        style: The style to apply to the characters.\n    \"\"\"\n    # Draw the quad as two filled high-resolution triangles\n    # First triangle (0, 1, 2)\n    self.draw_filled_hires_triangle(x0, y0, x1, y1, x2, y2, hires_mode, style)\n    # Second triangle (0, 2, 3)\n    self.draw_filled_hires_triangle(x0, y0, x2, y2, x3, y3, hires_mode, style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_filled_hires_triangle","title":"<code>draw_filled_hires_triangle(x0, y0, x1, y1, x2, y2, hires_mode=None, style='white')</code>","text":"<p>Draw a filled high-resolution triangle using the specified style. Uses a scanline algorithm with subpixel precision.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>float</code> <p>The x-coordinate of the first vertex.</p> required <code>y0</code> <code>float</code> <p>The y-coordinate of the first vertex.</p> required <code>x1</code> <code>float</code> <p>The x-coordinate of the second vertex.</p> required <code>y1</code> <code>float</code> <p>The y-coordinate of the second vertex.</p> required <code>x2</code> <code>float</code> <p>The x-coordinate of the third vertex.</p> required <code>y2</code> <code>float</code> <p>The y-coordinate of the third vertex.</p> required <code>hires_mode</code> <code>HiResMode | None</code> <p>The high-resolution mode to use.</p> <code>None</code> <code>style</code> <code>str</code> <p>The style to apply to the characters.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_filled_hires_triangle(\n    self,\n    x0: float,\n    y0: float,\n    x1: float,\n    y1: float,\n    x2: float,\n    y2: float,\n    hires_mode: HiResMode | None = None,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a filled high-resolution triangle using the specified style.\n    Uses a scanline algorithm with subpixel precision.\n\n    Args:\n        x0: The x-coordinate of the first vertex.\n        y0: The y-coordinate of the first vertex.\n        x1: The x-coordinate of the second vertex.\n        y1: The y-coordinate of the second vertex.\n        x2: The x-coordinate of the third vertex.\n        y2: The y-coordinate of the third vertex.\n        hires_mode: The high-resolution mode to use.\n        style: The style to apply to the characters.\n    \"\"\"\n    # Use default hires mode if none provided\n    hires_mode = hires_mode or self.default_hires_mode\n\n    # Sort vertices by y-coordinate (y0 &lt;= y1 &lt;= y2)\n    if y0 &gt; y1:\n        x0, y0, x1, y1 = x1, y1, x0, y0\n    if y1 &gt; y2:\n        x1, y1, x2, y2 = x2, y2, x1, y1\n    if y0 &gt; y1:\n        x0, y0, x1, y1 = x1, y1, x0, y0\n\n    # Skip if all points are the same or triangle has no height\n    if abs(y0 - y2) &lt; 1e-6:\n        return\n\n    # Initialize pixel collection\n    pixels: list[tuple[float, float]] = []\n    pixels_append = pixels.append\n\n    # Define helper function to add a hi-res pixel\n    def add_hires_pixel(x: float, y: float) -&gt; None:\n        pixels_append((x, y))\n\n    # No edge parameters needed\n\n    # Process based on triangle shape\n    if abs(y1 - y0) &lt; 1e-6:  # Flat top triangle\n        self._fill_flat_top_hires_triangle(x0, y0, x1, y1, x2, y2, add_hires_pixel)\n    elif abs(y1 - y2) &lt; 1e-6:  # Flat bottom triangle\n        self._fill_flat_bottom_hires_triangle(\n            x0, y0, x1, y1, x2, y2, add_hires_pixel\n        )\n    else:  # General triangle - split into flat-top and flat-bottom\n        # Calculate the interpolation factor for the split point\n        t = (y1 - y0) / (y2 - y0)\n\n        # Calculate the x-coordinate of the point on the long edge that has y = y1\n        x3 = x0 + t * (x2 - x0)\n\n        # Fill the flat bottom part\n        self._fill_flat_bottom_hires_triangle(\n            x0, y0, x1, y1, x3, y1, add_hires_pixel\n        )\n\n        # Fill the flat top part\n        self._fill_flat_top_hires_triangle(x1, y1, x3, y1, x2, y2, add_hires_pixel)\n\n    # Draw all hi-res pixels at once\n    if pixels:\n        self.set_hires_pixels(pixels, hires_mode, style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_filled_quad","title":"<code>draw_filled_quad(x0, y0, x1, y1, x2, y2, x3, y3, style='white')</code>","text":"<p>Draw a filled quadrilateral using the specified style. Splits the quad into two triangles for filling.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>int</code> <p>The x-coordinate of the first vertex.</p> required <code>y0</code> <code>int</code> <p>The y-coordinate of the first vertex.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the second vertex.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the second vertex.</p> required <code>x2</code> <code>int</code> <p>The x-coordinate of the third vertex.</p> required <code>y2</code> <code>int</code> <p>The y-coordinate of the third vertex.</p> required <code>x3</code> <code>int</code> <p>The x-coordinate of the fourth vertex.</p> required <code>y3</code> <code>int</code> <p>The y-coordinate of the fourth vertex.</p> required <code>style</code> <code>str</code> <p>The style to apply to the characters.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_filled_quad(\n    self,\n    x0: int,\n    y0: int,\n    x1: int,\n    y1: int,\n    x2: int,\n    y2: int,\n    x3: int,\n    y3: int,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a filled quadrilateral using the specified style.\n    Splits the quad into two triangles for filling.\n\n    Args:\n        x0: The x-coordinate of the first vertex.\n        y0: The y-coordinate of the first vertex.\n        x1: The x-coordinate of the second vertex.\n        y1: The y-coordinate of the second vertex.\n        x2: The x-coordinate of the third vertex.\n        y2: The y-coordinate of the third vertex.\n        x3: The x-coordinate of the fourth vertex.\n        y3: The y-coordinate of the fourth vertex.\n        style: The style to apply to the characters.\n    \"\"\"\n    # Draw the quad as two filled triangles\n    # First triangle (0, 1, 2)\n    self.draw_filled_triangle(x0, y0, x1, y1, x2, y2, style)\n    # Second triangle (0, 2, 3)\n    self.draw_filled_triangle(x0, y0, x2, y2, x3, y3, style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_filled_triangle","title":"<code>draw_filled_triangle(x0, y0, x1, y1, x2, y2, style='white')</code>","text":"<p>Draw a filled triangle using the specified style. Uses a scanline algorithm for efficient filling.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>int</code> <p>The x-coordinate of the first vertex.</p> required <code>y0</code> <code>int</code> <p>The y-coordinate of the first vertex.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the second vertex.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the second vertex.</p> required <code>x2</code> <code>int</code> <p>The x-coordinate of the third vertex.</p> required <code>y2</code> <code>int</code> <p>The y-coordinate of the third vertex.</p> required <code>style</code> <code>str</code> <p>The style to apply to the characters.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_filled_triangle(\n    self,\n    x0: int,\n    y0: int,\n    x1: int,\n    y1: int,\n    x2: int,\n    y2: int,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a filled triangle using the specified style.\n    Uses a scanline algorithm for efficient filling.\n\n    Args:\n        x0: The x-coordinate of the first vertex.\n        y0: The y-coordinate of the first vertex.\n        x1: The x-coordinate of the second vertex.\n        y1: The y-coordinate of the second vertex.\n        x2: The x-coordinate of the third vertex.\n        y2: The y-coordinate of the third vertex.\n        style: The style to apply to the characters.\n    \"\"\"\n    # Sort vertices by y-coordinate (y0 &lt;= y1 &lt;= y2)\n    if y0 &gt; y1:\n        x0, y0, x1, y1 = x1, y1, x0, y0\n    if y1 &gt; y2:\n        x1, y1, x2, y2 = x2, y2, x1, y1\n    if y0 &gt; y1:\n        x0, y0, x1, y1 = x1, y1, x0, y0\n\n    # Skip if all points are the same or triangle has no height\n    if (y0 == y1 == y2) or (y0 == y2):\n        return\n\n    # Initialize empty list for all pixel coordinates\n    pixels: list[tuple[int, int]] = []\n    pixels_append = pixels.append\n\n    # Calculate interpolation factor for the middle point\n    inv_slope02 = (x2 - x0) / (y2 - y0) if y2 != y0 else 0\n\n    # First half of the triangle (bottom flat or top)\n    if y1 == y0:  # Flat top triangle\n        self._fill_flat_top_triangle(x0, y0, x1, y1, x2, y2, pixels_append)\n    elif y1 == y2:  # Flat bottom triangle\n        self._fill_flat_bottom_triangle(x0, y0, x1, y1, x2, y2, pixels_append)\n    else:  # General triangle - split into flat-top and flat-bottom\n        # Calculate the x-coordinate of the point on the long edge that has y = y1\n        x3 = int(x0 + inv_slope02 * (y1 - y0))\n\n        # Fill the flat bottom part\n        self._fill_flat_bottom_triangle(x0, y0, x1, y1, x3, y1, pixels_append)\n\n        # Fill the flat top part\n        self._fill_flat_top_triangle(x1, y1, x3, y1, x2, y2, pixels_append)\n\n    # Draw all pixels at once\n    if pixels:\n        self.set_pixels(pixels, \"\u2588\", style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_hires_circle","title":"<code>draw_hires_circle(cx, cy, radius, hires_mode=None, style='white')</code>","text":"<p>Draw a circle with high-resolution support using Bresenham's algorithm. Compensates for 2:1 aspect ratio.</p> <p>Parameters:</p> Name Type Description Default <code>cx</code> <code>float</code> <p>X-coordinate of the center of the circle.</p> required <code>cy</code> <code>float</code> <p>Y-coordinate of the center of the circle.</p> required <code>radius</code> <code>float</code> <p>Radius of the circle.</p> required <code>hires_mode</code> <code>HiResMode</code> <p>The high-resolution mode to use.</p> <code>None</code> <code>style</code> <code>str</code> <p>Style of the pixels to be drawn.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_hires_circle(\n    self,\n    cx: float,\n    cy: float,\n    radius: float,\n    hires_mode: HiResMode | None = None,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a circle with high-resolution support using Bresenham's algorithm. Compensates for 2:1 aspect ratio.\n\n    Args:\n        cx (float): X-coordinate of the center of the circle.\n        cy (float): Y-coordinate of the center of the circle.\n        radius (float): Radius of the circle.\n        hires_mode (HiResMode): The high-resolution mode to use.\n        style (str): Style of the pixels to be drawn.\n    \"\"\"\n    # Early rejection for invalid inputs\n    if radius &lt;= 0:\n        return\n\n    # Initialize an empty list for collecting pixel coordinates\n    # (We calculate estimated_size only for the safety check below)\n    estimated_size = int(\n        radius * 16\n    )  # Each step adds 8 pixels, estimate 4*radius steps\n    pixels: list[tuple[float, float]] = []\n    pixels_extend = pixels.extend  # Local reference for faster calls\n\n    # Pre-compute constants\n    scale_x = 1\n    scale_y = 2\n    aspect_ratio = scale_x / scale_y\n\n    # Midpoint circle algorithm with floating point precision\n    x: float = radius\n    y: float = 0\n    decision: float = 1 - radius\n\n    # Pre-compute points for each octant to avoid repeated calculations\n    def get_circle_points(x: float, y: float) -&gt; list[tuple[float, float]]:\n        y_scaled = y * aspect_ratio\n        x_scaled = x * aspect_ratio\n        return [\n            (cx + x, cy + y_scaled),\n            (cx - x, cy + y_scaled),\n            (cx + x, cy - y_scaled),\n            (cx - x, cy - y_scaled),\n            (cx + y, cy + x_scaled),\n            (cx - y, cy + x_scaled),\n            (cx + y, cy - x_scaled),\n            (cx - y, cy - x_scaled),\n        ]\n\n    # Generate points for the circle\n    while y &lt;= x:\n        # Add all 8 points at once\n        pixels_extend(get_circle_points(x, y))\n\n        # Update position\n        y += 0.5\n        if decision &lt;= 0:\n            decision += 2 * y + 1\n        else:\n            x -= 0.5\n            decision += 2 * (y - x) + 1\n\n        # Safety check to avoid infinite loops\n        if len(pixels) &gt; estimated_size:\n            break\n\n    # Render all pixels at once\n    self.set_hires_pixels(pixels, hires_mode, style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_hires_line","title":"<code>draw_hires_line(x0, y0, x1, y1, hires_mode=None, style='white')</code>","text":"<p>Draws a high-resolution line from (x0, y0) to (x1, y1) using the specified character and style.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>float</code> <p>The x-coordinate of the start of the line.</p> required <code>y0</code> <code>float</code> <p>The y-coordinate of the start of the line.</p> required <code>x1</code> <code>float</code> <p>The x-coordinate of the end of the line.</p> required <code>y1</code> <code>float</code> <p>The y-coordinate of the end of the line.</p> required <code>hires_mode</code> <code>HiResMode | None</code> <p>The high-resolution mode to use.</p> <code>None</code> <code>style</code> <code>str</code> <p>The style to apply to the character.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_hires_line(\n    self,\n    x0: float,\n    y0: float,\n    x1: float,\n    y1: float,\n    hires_mode: HiResMode | None = None,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draws a high-resolution line from (x0, y0) to (x1, y1) using the specified character and style.\n\n    Args:\n        x0: The x-coordinate of the start of the line.\n        y0: The y-coordinate of the start of the line.\n        x1: The x-coordinate of the end of the line.\n        y1: The y-coordinate of the end of the line.\n        hires_mode: The high-resolution mode to use.\n        style: The style to apply to the character.\n    \"\"\"\n    self.draw_hires_lines([(x0, y0, x1, y1)], hires_mode, style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_hires_lines","title":"<code>draw_hires_lines(coordinates, hires_mode=None, style='white')</code>","text":"<p>Draws multiple high-resolution lines from given coordinates using the specified character and style.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Iterable[tuple[FloatScalar, FloatScalar, FloatScalar, FloatScalar]]</code> <p>An iterable of tuples representing the coordinates of the lines.</p> required <code>hires_mode</code> <code>HiResMode | None</code> <p>The high-resolution mode to use.</p> <code>None</code> <code>style</code> <code>str</code> <p>The style to apply to the character.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_hires_lines(\n    self,\n    coordinates: Iterable[\n        tuple[FloatScalar, FloatScalar, FloatScalar, FloatScalar]\n    ],\n    hires_mode: HiResMode | None = None,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draws multiple high-resolution lines from given coordinates using the specified character and style.\n\n    Args:\n        coordinates: An iterable of tuples representing the coordinates of the lines.\n        hires_mode: The high-resolution mode to use.\n        style: The style to apply to the character.\n    \"\"\"\n    # Early out if no coordinates\n    if not coordinates:\n        return\n\n    # Convert to list if not already for multiple passes\n    coord_list = list(coordinates)\n\n    hires_mode = hires_mode or self.default_hires_mode\n    pixel_size = hires_sizes[hires_mode]\n\n    # Pre-compute multiplication factors once\n    w_factor = pixel_size.width\n    h_factor = pixel_size.height\n    inv_w_factor = 1.0 / w_factor\n    inv_h_factor = 1.0 / h_factor\n\n    # Initialize an empty list for collecting pixel coordinates\n    pixels: list[tuple[float, float]] = []\n    pixels_append = pixels.append  # Local reference for faster calls\n\n    # Process each line\n    for x0, y0, x1, y1 in coord_list:\n        # Skip if both endpoints are outside canvas (optimization)\n        if not self._canvas_region.contains(\n            floor(x0), floor(y0)\n        ) and not self._canvas_region.contains(floor(x1), floor(y1)):\n            continue\n\n        # Convert to high-res grid coordinates\n        hx0 = floor(x0 * w_factor)\n        hy0 = floor(y0 * h_factor)\n        hx1 = floor(x1 * w_factor)\n        hy1 = floor(y1 * h_factor)\n\n        # Get line coordinates\n        coords = self._get_line_coordinates(hx0, hy0, hx1, hy1)\n\n        # Convert back to canvas space and add to pixel array\n        # Use direct append and precalculated factors for better performance\n        for x, y in coords:\n            pixels_append((x * inv_w_factor, y * inv_h_factor))\n\n    # Only make one call to set_hires_pixels with all points\n    if pixels:\n        self.set_hires_pixels(pixels, hires_mode, style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_hires_quad","title":"<code>draw_hires_quad(x0, y0, x1, y1, x2, y2, x3, y3, hires_mode=None, style='white')</code>","text":"<p>Draw a high-resolution quadrilateral outline using the specified style.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>float</code> <p>The x-coordinate of the first vertex.</p> required <code>y0</code> <code>float</code> <p>The y-coordinate of the first vertex.</p> required <code>x1</code> <code>float</code> <p>The x-coordinate of the second vertex.</p> required <code>y1</code> <code>float</code> <p>The y-coordinate of the second vertex.</p> required <code>x2</code> <code>float</code> <p>The x-coordinate of the third vertex.</p> required <code>y2</code> <code>float</code> <p>The y-coordinate of the third vertex.</p> required <code>x3</code> <code>float</code> <p>The x-coordinate of the fourth vertex.</p> required <code>y3</code> <code>float</code> <p>The y-coordinate of the fourth vertex.</p> required <code>hires_mode</code> <code>HiResMode | None</code> <p>The high-resolution mode to use.</p> <code>None</code> <code>style</code> <code>str</code> <p>The style to apply to the characters.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_hires_quad(\n    self,\n    x0: float,\n    y0: float,\n    x1: float,\n    y1: float,\n    x2: float,\n    y2: float,\n    x3: float,\n    y3: float,\n    hires_mode: HiResMode | None = None,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a high-resolution quadrilateral outline using the specified style.\n\n    Args:\n        x0: The x-coordinate of the first vertex.\n        y0: The y-coordinate of the first vertex.\n        x1: The x-coordinate of the second vertex.\n        y1: The y-coordinate of the second vertex.\n        x2: The x-coordinate of the third vertex.\n        y2: The y-coordinate of the third vertex.\n        x3: The x-coordinate of the fourth vertex.\n        y3: The y-coordinate of the fourth vertex.\n        hires_mode: The high-resolution mode to use.\n        style: The style to apply to the characters.\n    \"\"\"\n    # Draw the four sides of the quadrilateral with high-resolution\n    self.draw_hires_lines(\n        [(x0, y0, x1, y1), (x1, y1, x2, y2), (x2, y2, x3, y3), (x3, y3, x0, y0)],\n        hires_mode,\n        style,\n    )\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_hires_triangle","title":"<code>draw_hires_triangle(x0, y0, x1, y1, x2, y2, hires_mode=None, style='white')</code>","text":"<p>Draw a high-resolution triangle outline using the specified style.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>float</code> <p>The x-coordinate of the first vertex.</p> required <code>y0</code> <code>float</code> <p>The y-coordinate of the first vertex.</p> required <code>x1</code> <code>float</code> <p>The x-coordinate of the second vertex.</p> required <code>y1</code> <code>float</code> <p>The y-coordinate of the second vertex.</p> required <code>x2</code> <code>float</code> <p>The x-coordinate of the third vertex.</p> required <code>y2</code> <code>float</code> <p>The y-coordinate of the third vertex.</p> required <code>hires_mode</code> <code>HiResMode | None</code> <p>The high-resolution mode to use.</p> <code>None</code> <code>style</code> <code>str</code> <p>The style to apply to the characters.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_hires_triangle(\n    self,\n    x0: float,\n    y0: float,\n    x1: float,\n    y1: float,\n    x2: float,\n    y2: float,\n    hires_mode: HiResMode | None = None,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a high-resolution triangle outline using the specified style.\n\n    Args:\n        x0: The x-coordinate of the first vertex.\n        y0: The y-coordinate of the first vertex.\n        x1: The x-coordinate of the second vertex.\n        y1: The y-coordinate of the second vertex.\n        x2: The x-coordinate of the third vertex.\n        y2: The y-coordinate of the third vertex.\n        hires_mode: The high-resolution mode to use.\n        style: The style to apply to the characters.\n    \"\"\"\n\n    # Draw the three sides of the triangle with high-resolution\n    self.draw_hires_lines(\n        [(x0, y0, x1, y1), (x1, y1, x2, y2), (x2, y2, x0, y0)], hires_mode, style\n    )\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_line","title":"<code>draw_line(x0, y0, x1, y1, char='\u2588', style='white')</code>","text":"<p>Draws a line from (x0, y0) to (x1, y1) using the specified character and style.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>int</code> <p>The x-coordinate of the start of the line.</p> required <code>y0</code> <code>int</code> <p>The y-coordinate of the start of the line.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the end of the line.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the end of the line.</p> required <code>char</code> <code>str</code> <p>The character to draw.</p> <code>'\u2588'</code> <code>style</code> <code>str</code> <p>The style to apply to the character.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_line(\n    self, x0: int, y0: int, x1: int, y1: int, char: str = \"\u2588\", style: str = \"white\"\n) -&gt; None:\n    \"\"\"Draws a line from (x0, y0) to (x1, y1) using the specified character and style.\n\n    Args:\n        x0: The x-coordinate of the start of the line.\n        y0: The y-coordinate of the start of the line.\n        x1: The x-coordinate of the end of the line.\n        y1: The y-coordinate of the end of the line.\n        char: The character to draw.\n        style: The style to apply to the character.\n    \"\"\"\n    if not self._canvas_region.contains(\n        x0, y0\n    ) and not self._canvas_region.contains(x1, y1):\n        return\n    self.set_pixels(self._get_line_coordinates(x0, y0, x1, y1), char, style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_lines","title":"<code>draw_lines(coordinates, char='\u2588', style='white')</code>","text":"<p>Draws multiple lines from given coordinates using the specified character and style.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Iterable[tuple[int, int, int, int]]</code> <p>An iterable of tuples representing the coordinates of the lines.</p> required <code>char</code> <code>str</code> <p>The character to draw.</p> <code>'\u2588'</code> <code>style</code> <code>str</code> <p>The style to apply to the character.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_lines(\n    self,\n    coordinates: Iterable[tuple[int, int, int, int]],\n    char: str = \"\u2588\",\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draws multiple lines from given coordinates using the specified character and style.\n\n    Args:\n        coordinates: An iterable of tuples representing the coordinates of the lines.\n        char: The character to draw.\n        style: The style to apply to the character.\n    \"\"\"\n    # Convert to list for multiple passes\n    coord_list = list(coordinates)\n    if not coord_list:\n        return\n\n    # Collect all pixels from all lines before rendering\n    all_pixels = []\n\n    for x0, y0, x1, y1 in coord_list:\n        # Skip if both endpoints are outside the canvas\n        if not self._canvas_region.contains(\n            x0, y0\n        ) and not self._canvas_region.contains(x1, y1):\n            continue\n\n        # Get coordinates for this line and extend the pixel collection\n        line_pixels = self._get_line_coordinates(x0, y0, x1, y1)\n        all_pixels.extend(line_pixels)\n\n    # Draw all pixels at once with a single refresh\n    if all_pixels:\n        self.set_pixels(all_pixels, char, style)\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_quad","title":"<code>draw_quad(x0, y0, x1, y1, x2, y2, x3, y3, style='white')</code>","text":"<p>Draw a quadrilateral outline using the specified style.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>int</code> <p>The x-coordinate of the first vertex.</p> required <code>y0</code> <code>int</code> <p>The y-coordinate of the first vertex.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the second vertex.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the second vertex.</p> required <code>x2</code> <code>int</code> <p>The x-coordinate of the third vertex.</p> required <code>y2</code> <code>int</code> <p>The y-coordinate of the third vertex.</p> required <code>x3</code> <code>int</code> <p>The x-coordinate of the fourth vertex.</p> required <code>y3</code> <code>int</code> <p>The y-coordinate of the fourth vertex.</p> required <code>style</code> <code>str</code> <p>The style to apply to the characters.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_quad(\n    self,\n    x0: int,\n    y0: int,\n    x1: int,\n    y1: int,\n    x2: int,\n    y2: int,\n    x3: int,\n    y3: int,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a quadrilateral outline using the specified style.\n\n    Args:\n        x0: The x-coordinate of the first vertex.\n        y0: The y-coordinate of the first vertex.\n        x1: The x-coordinate of the second vertex.\n        y1: The y-coordinate of the second vertex.\n        x2: The x-coordinate of the third vertex.\n        y2: The y-coordinate of the third vertex.\n        x3: The x-coordinate of the fourth vertex.\n        y3: The y-coordinate of the fourth vertex.\n        style: The style to apply to the characters.\n    \"\"\"\n    # Draw the four sides of the quadrilateral\n    self.draw_lines(\n        [(x0, y0, x1, y1), (x1, y1, x2, y2), (x2, y2, x3, y3), (x3, y3, x0, y0)],\n        \"\u2588\",\n        style,\n    )\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_rectangle_box","title":"<code>draw_rectangle_box(x0, y0, x1, y1, thickness=1, style='white')</code>","text":"<p>Draw a rectangle box with the specified thickness and style.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>int</code> <p>The x-coordinate of the top-left corner.</p> required <code>y0</code> <code>int</code> <p>The y-coordinate of the top-left corner.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the bottom-right corner.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the bottom-right corner.</p> required <code>thickness</code> <code>int</code> <p>The thickness of the box.</p> <code>1</code> <code>style</code> <code>str</code> <p>The style to apply to the characters.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_rectangle_box(\n    self,\n    x0: int,\n    y0: int,\n    x1: int,\n    y1: int,\n    thickness: int = 1,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a rectangle box with the specified thickness and style.\n\n    Args:\n        x0: The x-coordinate of the top-left corner.\n        y0: The y-coordinate of the top-left corner.\n        x1: The x-coordinate of the bottom-right corner.\n        y1: The y-coordinate of the bottom-right corner.\n        thickness: The thickness of the box.\n        style: The style to apply to the characters.\n    \"\"\"\n    # (x0, y0)     (x1, y0)\n    #    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    #    \u2502            \u2502\n    #    \u2502            \u2502\n    #    \u2502            \u2502\n    #    \u2502            \u2502\n    #    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    # (x0, y1)     (x1, y1)\n\n    # NOTE: A difference of 0 between coordinates results in a\n    # width or height of 1 cell inside Textual.\n\n    T = thickness\n    x0, x1 = sorted((x0, x1))\n    y0, y1 = sorted((y0, y1))\n\n    # Both width and height are 1. This would just be a dot, so\n    # we don't draw anything.\n    if (x1 - x0 == 0) and (y1 - y0 == 0):\n        return\n\n    # We now know either the width or height must be higher than 2.\n    # Height is 1, place two horizontal line enders.\n    if y1 - y0 == 0:\n        self.set_pixel(x0, y0, char=get_box((0, T, 0, 0)), style=style)\n        self.set_pixel(x1, y0, char=get_box((0, 0, 0, T)), style=style)\n        if x1 - x0 &gt;= 2:\n            # Width is greater than or equal to 3, draw a horizontal line\n            # between the line enders.\n            self.draw_line(\n                x0 + 1, y0, x1 - 1, y1, char=get_box((0, T, 0, T)), style=style\n            )\n        return\n\n    # Width is 1, place two vertical line enders.\n    if x1 - x0 == 0:\n        self.set_pixel(x0, y0, char=get_box((0, 0, T, 0)), style=style)\n        self.set_pixel(x0, y1, char=get_box((T, 0, 0, 0)), style=style)\n        if y1 - y0 &gt;= 2:\n            # Height is greater than or equal to 3, draw a horizontal line\n            # between the line enders.\n            self.draw_line(\n                x0, y0 + 1, x1, y1 - 1, char=get_box((T, 0, T, 0)), style=style\n            )\n        return\n\n    # The remaining conditions require all the corner pieces to be drawn.\n    self.set_pixel(x0, y0, char=get_box((0, T, T, 0)), style=style)\n    self.set_pixel(x1, y0, char=get_box((0, 0, T, T)), style=style)\n    self.set_pixel(x1, y1, char=get_box((T, 0, 0, T)), style=style)\n    self.set_pixel(x0, y1, char=get_box((T, T, 0, 0)), style=style)\n\n    # If width and height are both 2, we don't need any lines. Only corners.\n    if (x1 - x0 == 1) and (y1 - y0 == 1):\n        return\n\n    # Width is greater than or equal to 3, draw horizontal lines.\n    if x1 - x0 &gt;= 2:\n        for y in y0, y1:\n            self.draw_line(\n                x0 + 1, y, x1 - 1, y, char=get_box((0, T, 0, T)), style=style\n            )\n    # Height is greater than or equal to 3, draw vertical lines.\n    if y1 - y0 &gt;= 2:\n        for x in x0, x1:\n            self.draw_line(\n                x, y0 + 1, x, y1 - 1, char=get_box((T, 0, T, 0)), style=style\n            )\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.draw_triangle","title":"<code>draw_triangle(x0, y0, x1, y1, x2, y2, style='white')</code>","text":"<p>Draw a triangle outline using the specified style.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>int</code> <p>The x-coordinate of the first vertex.</p> required <code>y0</code> <code>int</code> <p>The y-coordinate of the first vertex.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the second vertex.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the second vertex.</p> required <code>x2</code> <code>int</code> <p>The x-coordinate of the third vertex.</p> required <code>y2</code> <code>int</code> <p>The y-coordinate of the third vertex.</p> required <code>style</code> <code>str</code> <p>The style to apply to the characters.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def draw_triangle(\n    self,\n    x0: int,\n    y0: int,\n    x1: int,\n    y1: int,\n    x2: int,\n    y2: int,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Draw a triangle outline using the specified style.\n\n    Args:\n        x0: The x-coordinate of the first vertex.\n        y0: The y-coordinate of the first vertex.\n        x1: The x-coordinate of the second vertex.\n        y1: The y-coordinate of the second vertex.\n        x2: The x-coordinate of the third vertex.\n        y2: The y-coordinate of the third vertex.\n        style: The style to apply to the characters.\n    \"\"\"\n\n    # Draw the three sides of the triangle\n    self.draw_lines(\n        [(x0, y0, x1, y1), (x1, y1, x2, y2), (x2, y2, x0, y0)], \"\u2588\", style\n    )\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.get_pixel","title":"<code>get_pixel(x, y)</code>","text":"<p>Retrieves the character and style of a single pixel at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x-coordinate of the pixel.</p> required <code>y</code> <code>int</code> <p>The y-coordinate of the pixel.</p> required <p>Returns:     A tuple containing the character and style of the pixel.</p> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def get_pixel(self, x: int, y: int) -&gt; tuple[str, str]:\n    \"\"\"Retrieves the character and style of a single pixel at the given coordinates.\n\n    Args:\n        x: The x-coordinate of the pixel.\n        y: The y-coordinate of the pixel.\n    Returns:\n        A tuple containing the character and style of the pixel.\n    \"\"\"\n    return self._buffer[y][x], self._styles[y][x]\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.render_line","title":"<code>render_line(y)</code>","text":"<p>Renders a single line of the canvas at the given y-coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>int</code> <p>The y-coordinate of the line.</p> required <p>Returns:     A Strip representing the line.</p> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def render_line(self, y: int) -&gt; Strip:\n    \"\"\"Renders a single line of the canvas at the given y-coordinate.\n\n    Args:\n        y: The y-coordinate of the line.\n    Returns:\n        A Strip representing the line.\n    \"\"\"\n    # Fast path for out-of-bounds or uninitialized\n    if not self._canvas_size.area or y &gt;= self._canvas_size.height:\n        return Strip.blank(cell_length=0)\n\n    buffer_line = self._buffer[y]\n    styles_line = self._styles[y]\n\n    # Fast path for blank lines\n    if all(char == \" \" for char in buffer_line):\n        return Strip.blank(cell_length=len(buffer_line))\n\n    # Create segments with batching by style\n    segments: list[Segment] = []\n    append = segments.append  # Local reference for faster calls\n\n    # Batch processing for same style segments\n    current_style_str = None\n    current_style_obj = None\n    current_text = \"\"\n\n    for char, style_str in zip(buffer_line, styles_line):\n        # When style changes, add current batch and start new one\n        if style_str != current_style_str:\n            # Add current batch if it exists\n            if current_text:\n                append(Segment(current_text, style=current_style_obj))\n\n            # Start new batch\n            current_style_str = style_str\n            current_text = char\n\n            # Get style object from cache or create new one\n            if style_str:\n                if style_str not in self._style_cache:\n                    self._style_cache[style_str] = Style.parse(style_str)\n                current_style_obj = self._style_cache[style_str]\n            else:\n                current_style_obj = None\n        else:\n            # Add to current batch\n            current_text += char\n\n    # Add the final batch\n    if current_text:\n        append(Segment(current_text, style=current_style_obj))\n\n    return Strip(segments).simplify()\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.reset","title":"<code>reset(size=None, refresh=True)</code>","text":"<p>Resets the canvas to the specified size or to the current size if no size is provided. Clears buffers,styles and dirty cache, and resets the canvas size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Size | None</code> <p>The new size for the canvas.</p> <code>None</code> <code>refresh</code> <code>bool</code> <p>Whether to refresh the canvas after resetting.</p> <code>True</code> <p>Returns:     self for chaining.</p> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def reset(self, size: Size | None = None, refresh: bool = True) -&gt; None:\n    \"\"\"Resets the canvas to the specified size or to the current size if no size is provided.\n    Clears buffers,styles and dirty cache, and resets the canvas size.\n\n    Args:\n        size: The new size for the canvas.\n        refresh: Whether to refresh the canvas after resetting.\n    Returns:\n        self for chaining.\n    \"\"\"\n    # Update size and regions if provided\n    if size:\n        self._canvas_size = size\n        self._canvas_region = Region(0, 0, size.width, size.height)\n\n    # Initialize buffers if we have a valid size\n    if self._canvas_size:\n        width = self._canvas_size.width\n        height = self._canvas_size.height\n\n        # More efficient buffer creation using list comprehension with multiplication\n        # This is significantly faster than nested loops for large buffers\n        self._buffer = [[\" \"] * width for _ in range(height)]\n        self._styles = [[\"\"] * width for _ in range(height)]\n\n    # Only refresh if requested\n    if refresh:\n        self.refresh()\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.set_hires_pixels","title":"<code>set_hires_pixels(coordinates, hires_mode=None, style='white')</code>","text":"<p>Sets multiple pixels at the given coordinates using the specified Hi-Res mode.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Iterable[tuple[FloatScalar, FloatScalar]]</code> <p>An iterable of tuples representing the coordinates of the pixels.</p> required <code>hires_mode</code> <code>HiResMode | None</code> <p>The Hi-Res mode to use.</p> <code>None</code> <code>style</code> <code>str</code> <p>The style to apply to the character.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def set_hires_pixels(\n    self,\n    coordinates: Iterable[tuple[FloatScalar, FloatScalar]],\n    hires_mode: HiResMode | None = None,\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Sets multiple pixels at the given coordinates using the specified Hi-Res mode.\n\n    Args:\n        coordinates: An iterable of tuples representing the coordinates of the pixels.\n        hires_mode: The Hi-Res mode to use.\n        style: The style to apply to the character.\n    \"\"\"\n    # Use default mode if none provided\n    hires_mode = hires_mode or self.default_hires_mode\n    pixel_size = hires_sizes[hires_mode]\n    pixel_info = pixels.get(hires_mode)\n    assert pixel_info is not None\n\n    # Group coordinates by their cell position to minimize buffer operations\n    cells_to_update: dict[tuple[int, int], set[tuple[int, int]]] = {}\n\n    # Pre-compute these values outside the loop for better performance\n    w_factor = pixel_size.width\n    h_factor = pixel_size.height\n\n    # Process all coordinates and group them by their target cell\n    for x, y in coordinates:\n        # Early rejection for out-of-bounds\n        if not self._canvas_region.contains(floor(x), floor(y)):\n            continue\n\n        # Calculate high-res coordinates\n        hx = floor(x * w_factor)\n        hy = floor(y * h_factor)\n\n        # Calculate which cell this belongs to and offset within cell\n        cell_x = hx // w_factor\n        cell_y = hy // h_factor\n\n        # Get or create the set for this cell\n        cell_key = (cell_x, cell_y)\n        if cell_key not in cells_to_update:\n            cells_to_update[cell_key] = set()\n\n        # Add this point to the cell's set\n        offset_x = hx % w_factor\n        offset_y = hy % h_factor\n        cells_to_update[cell_key].add((offset_x, offset_y))\n\n    # Process each cell that needs updating\n    for (cell_x, cell_y), points in cells_to_update.items():\n        # Create a small buffer just for this cell\n        cell_buffer = np.zeros((pixel_size.height, pixel_size.width), dtype=bool)\n\n        # Mark each point in the buffer\n        for offset_x, offset_y in points:\n            cell_buffer[offset_y, offset_x] = True\n\n        # Convert to subpixels and look up the character\n        subpixels = tuple(int(v) for v in cell_buffer.flat)\n        if char := pixel_info[subpixels]:\n            self.set_pixel(\n                cell_x,\n                cell_y,\n                char=char,\n                style=style,\n            )\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.set_pixel","title":"<code>set_pixel(x, y, char='\u2588', style='white')</code>","text":"<p>Sets a single pixel at the given coordinates. Also marks it dirty for refreshing.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x-coordinate of the pixel.</p> required <code>y</code> <code>int</code> <p>The y-coordinate of the pixel.</p> required <code>char</code> <code>str</code> <p>The character to draw.</p> <code>'\u2588'</code> <code>style</code> <code>str</code> <p>The style to apply to the character.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def set_pixel(self, x: int, y: int, char: str = \"\u2588\", style: str = \"white\") -&gt; None:\n    \"\"\"Sets a single pixel at the given coordinates.\n    Also marks it dirty for refreshing.\n\n    Args:\n        x: The x-coordinate of the pixel.\n        y: The y-coordinate of the pixel.\n        char: The character to draw.\n        style: The style to apply to the character.\n    \"\"\"\n    # Fast rejection path without assert for performance\n    if not (\n        0 &lt;= x &lt; self._canvas_region.width and 0 &lt;= y &lt; self._canvas_region.height\n    ):\n        return\n\n    self._buffer[y][x] = char\n    self._styles[y][x] = style\n    self.refresh()\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.set_pixels","title":"<code>set_pixels(coordinates, char='\u2588', style='white')</code>","text":"<p>Sets multiple pixels at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Iterable[tuple[int, int]]</code> <p>An iterable of tuples representing the coordinates of the pixels.</p> required <code>char</code> <code>str</code> <p>The character to draw.</p> <code>'\u2588'</code> <code>style</code> <code>str</code> <p>The style to apply to the character.</p> <code>'white'</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def set_pixels(\n    self,\n    coordinates: Iterable[tuple[int, int]],\n    char: str = \"\u2588\",\n    style: str = \"white\",\n) -&gt; None:\n    \"\"\"Sets multiple pixels at the given coordinates.\n\n    Args:\n        coordinates: An iterable of tuples representing the coordinates of the pixels.\n        char: The character to draw.\n        style: The style to apply to the character.\n    \"\"\"\n    # Check if we have coordinates\n    coord_list = list(coordinates)\n    if not coord_list:\n        return\n\n    # Batch updates to avoid calling refresh for each pixel\n    # Cache properties for faster access in the loop\n    buffer = self._buffer\n    styles = self._styles\n    width = self._canvas_region.width\n    height = self._canvas_region.height\n\n    # Process all pixels first, then refresh once\n    for x, y in coord_list:\n        if 0 &lt;= x &lt; width and 0 &lt;= y &lt; height:\n            buffer[y][x] = char\n            styles[y][x] = style\n\n    # Only refresh once after all updates\n    self.refresh()\n</code></pre>"},{"location":"reference/#textual_hires_canvas.Canvas.write_text","title":"<code>write_text(x, y, text, align=TextAlign.LEFT)</code>","text":"<p>Write text to the canvas at the specified position, with support for markup.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X-coordinate of the left edge of the text.</p> required <code>y</code> <code>int</code> <p>Y-coordinate of the baseline of the text.</p> required <code>text</code> <code>str</code> <p>Text to be written.</p> required <code>align</code> <code>TextAlign</code> <p>The alignment of the text within the canvas.</p> <code>LEFT</code> Source code in <code>src/textual_hires_canvas/canvas.py</code> <pre><code>def write_text(\n    self,\n    x: int,\n    y: int,\n    text: str,\n    align: TextAlign = TextAlign.LEFT,\n) -&gt; None:\n    \"\"\"Write text to the canvas at the specified position, with support for markup.\n\n    Args:\n        x (int): X-coordinate of the left edge of the text.\n        y (int): Y-coordinate of the baseline of the text.\n        text (str): Text to be written.\n        align (TextAlign): The alignment of the text within the canvas.\n    \"\"\"\n    if y &lt; 0 or y &gt;= self._canvas_size.height:\n        return\n\n    # parse markup\n    rich_text = Text.from_markup(text)\n    # store plain text\n    if (plain_text := rich_text.plain) == \"\":\n        return\n    # store styles for each individual character\n    rich_styles = []\n    for c in rich_text.divide(range(1, len(plain_text))):\n        style = Style()\n        for span in c._spans:\n            style += Style.parse(span.style)\n        rich_styles.append(style)\n\n    if align == TextAlign.RIGHT:\n        x -= len(plain_text) - 1\n    elif align == TextAlign.CENTER:\n        div, mod = divmod(len(plain_text), 2)\n        x -= div\n        if mod == 0:\n            # even number of characters, shift one to the right since I just\n            # like that better -- DF\n            x += 1\n\n    if x &lt;= -len(plain_text) or x &gt;= self._canvas_size.width:\n        # no part of text falls inside the canvas\n        return\n\n    overflow_left = -x\n    overflow_right = x + len(plain_text) - self._canvas_size.width\n    if overflow_left &gt; 0:\n        buffer_left = 0\n        text_left = overflow_left\n    else:\n        buffer_left = x\n        text_left = 0\n    if overflow_right &gt; 0:\n        buffer_right = None\n        text_right = -overflow_right\n    else:\n        buffer_right = x + len(plain_text)\n        text_right = None\n\n    self._buffer[y][buffer_left:buffer_right] = plain_text[text_left:text_right]\n    self._styles[y][buffer_left:buffer_right] = [\n        str(s) for s in rich_styles[text_left:text_right]\n    ]\n    assert len(self._buffer[y]) == self._canvas_size.width\n    assert len(self._styles[y]) == self._canvas_size.width\n    self.refresh()\n</code></pre>"}]}